/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _SYSCALL_H: u32 = 1;
pub const __X32_SYSCALL_BIT: u32 = 1073741824;
pub const __NR_read: u32 = 0;
pub const __NR_write: u32 = 1;
pub const __NR_open: u32 = 2;
pub const __NR_close: u32 = 3;
pub const __NR_stat: u32 = 4;
pub const __NR_fstat: u32 = 5;
pub const __NR_lstat: u32 = 6;
pub const __NR_poll: u32 = 7;
pub const __NR_lseek: u32 = 8;
pub const __NR_mmap: u32 = 9;
pub const __NR_mprotect: u32 = 10;
pub const __NR_munmap: u32 = 11;
pub const __NR_brk: u32 = 12;
pub const __NR_rt_sigaction: u32 = 13;
pub const __NR_rt_sigprocmask: u32 = 14;
pub const __NR_rt_sigreturn: u32 = 15;
pub const __NR_ioctl: u32 = 16;
pub const __NR_pread64: u32 = 17;
pub const __NR_pwrite64: u32 = 18;
pub const __NR_readv: u32 = 19;
pub const __NR_writev: u32 = 20;
pub const __NR_access: u32 = 21;
pub const __NR_pipe: u32 = 22;
pub const __NR_select: u32 = 23;
pub const __NR_sched_yield: u32 = 24;
pub const __NR_mremap: u32 = 25;
pub const __NR_msync: u32 = 26;
pub const __NR_mincore: u32 = 27;
pub const __NR_madvise: u32 = 28;
pub const __NR_shmget: u32 = 29;
pub const __NR_shmat: u32 = 30;
pub const __NR_shmctl: u32 = 31;
pub const __NR_dup: u32 = 32;
pub const __NR_dup2: u32 = 33;
pub const __NR_pause: u32 = 34;
pub const __NR_nanosleep: u32 = 35;
pub const __NR_getitimer: u32 = 36;
pub const __NR_alarm: u32 = 37;
pub const __NR_setitimer: u32 = 38;
pub const __NR_getpid: u32 = 39;
pub const __NR_sendfile: u32 = 40;
pub const __NR_socket: u32 = 41;
pub const __NR_connect: u32 = 42;
pub const __NR_accept: u32 = 43;
pub const __NR_sendto: u32 = 44;
pub const __NR_recvfrom: u32 = 45;
pub const __NR_sendmsg: u32 = 46;
pub const __NR_recvmsg: u32 = 47;
pub const __NR_shutdown: u32 = 48;
pub const __NR_bind: u32 = 49;
pub const __NR_listen: u32 = 50;
pub const __NR_getsockname: u32 = 51;
pub const __NR_getpeername: u32 = 52;
pub const __NR_socketpair: u32 = 53;
pub const __NR_setsockopt: u32 = 54;
pub const __NR_getsockopt: u32 = 55;
pub const __NR_clone: u32 = 56;
pub const __NR_fork: u32 = 57;
pub const __NR_vfork: u32 = 58;
pub const __NR_execve: u32 = 59;
pub const __NR_exit: u32 = 60;
pub const __NR_wait4: u32 = 61;
pub const __NR_kill: u32 = 62;
pub const __NR_uname: u32 = 63;
pub const __NR_semget: u32 = 64;
pub const __NR_semop: u32 = 65;
pub const __NR_semctl: u32 = 66;
pub const __NR_shmdt: u32 = 67;
pub const __NR_msgget: u32 = 68;
pub const __NR_msgsnd: u32 = 69;
pub const __NR_msgrcv: u32 = 70;
pub const __NR_msgctl: u32 = 71;
pub const __NR_fcntl: u32 = 72;
pub const __NR_flock: u32 = 73;
pub const __NR_fsync: u32 = 74;
pub const __NR_fdatasync: u32 = 75;
pub const __NR_truncate: u32 = 76;
pub const __NR_ftruncate: u32 = 77;
pub const __NR_getdents: u32 = 78;
pub const __NR_getcwd: u32 = 79;
pub const __NR_chdir: u32 = 80;
pub const __NR_fchdir: u32 = 81;
pub const __NR_rename: u32 = 82;
pub const __NR_mkdir: u32 = 83;
pub const __NR_rmdir: u32 = 84;
pub const __NR_creat: u32 = 85;
pub const __NR_link: u32 = 86;
pub const __NR_unlink: u32 = 87;
pub const __NR_symlink: u32 = 88;
pub const __NR_readlink: u32 = 89;
pub const __NR_chmod: u32 = 90;
pub const __NR_fchmod: u32 = 91;
pub const __NR_chown: u32 = 92;
pub const __NR_fchown: u32 = 93;
pub const __NR_lchown: u32 = 94;
pub const __NR_umask: u32 = 95;
pub const __NR_gettimeofday: u32 = 96;
pub const __NR_getrlimit: u32 = 97;
pub const __NR_getrusage: u32 = 98;
pub const __NR_sysinfo: u32 = 99;
pub const __NR_times: u32 = 100;
pub const __NR_ptrace: u32 = 101;
pub const __NR_getuid: u32 = 102;
pub const __NR_syslog: u32 = 103;
pub const __NR_getgid: u32 = 104;
pub const __NR_setuid: u32 = 105;
pub const __NR_setgid: u32 = 106;
pub const __NR_geteuid: u32 = 107;
pub const __NR_getegid: u32 = 108;
pub const __NR_setpgid: u32 = 109;
pub const __NR_getppid: u32 = 110;
pub const __NR_getpgrp: u32 = 111;
pub const __NR_setsid: u32 = 112;
pub const __NR_setreuid: u32 = 113;
pub const __NR_setregid: u32 = 114;
pub const __NR_getgroups: u32 = 115;
pub const __NR_setgroups: u32 = 116;
pub const __NR_setresuid: u32 = 117;
pub const __NR_getresuid: u32 = 118;
pub const __NR_setresgid: u32 = 119;
pub const __NR_getresgid: u32 = 120;
pub const __NR_getpgid: u32 = 121;
pub const __NR_setfsuid: u32 = 122;
pub const __NR_setfsgid: u32 = 123;
pub const __NR_getsid: u32 = 124;
pub const __NR_capget: u32 = 125;
pub const __NR_capset: u32 = 126;
pub const __NR_rt_sigpending: u32 = 127;
pub const __NR_rt_sigtimedwait: u32 = 128;
pub const __NR_rt_sigqueueinfo: u32 = 129;
pub const __NR_rt_sigsuspend: u32 = 130;
pub const __NR_sigaltstack: u32 = 131;
pub const __NR_utime: u32 = 132;
pub const __NR_mknod: u32 = 133;
pub const __NR_uselib: u32 = 134;
pub const __NR_personality: u32 = 135;
pub const __NR_ustat: u32 = 136;
pub const __NR_statfs: u32 = 137;
pub const __NR_fstatfs: u32 = 138;
pub const __NR_sysfs: u32 = 139;
pub const __NR_getpriority: u32 = 140;
pub const __NR_setpriority: u32 = 141;
pub const __NR_sched_setparam: u32 = 142;
pub const __NR_sched_getparam: u32 = 143;
pub const __NR_sched_setscheduler: u32 = 144;
pub const __NR_sched_getscheduler: u32 = 145;
pub const __NR_sched_get_priority_max: u32 = 146;
pub const __NR_sched_get_priority_min: u32 = 147;
pub const __NR_sched_rr_get_interval: u32 = 148;
pub const __NR_mlock: u32 = 149;
pub const __NR_munlock: u32 = 150;
pub const __NR_mlockall: u32 = 151;
pub const __NR_munlockall: u32 = 152;
pub const __NR_vhangup: u32 = 153;
pub const __NR_modify_ldt: u32 = 154;
pub const __NR_pivot_root: u32 = 155;
pub const __NR__sysctl: u32 = 156;
pub const __NR_prctl: u32 = 157;
pub const __NR_arch_prctl: u32 = 158;
pub const __NR_adjtimex: u32 = 159;
pub const __NR_setrlimit: u32 = 160;
pub const __NR_chroot: u32 = 161;
pub const __NR_sync: u32 = 162;
pub const __NR_acct: u32 = 163;
pub const __NR_settimeofday: u32 = 164;
pub const __NR_mount: u32 = 165;
pub const __NR_umount2: u32 = 166;
pub const __NR_swapon: u32 = 167;
pub const __NR_swapoff: u32 = 168;
pub const __NR_reboot: u32 = 169;
pub const __NR_sethostname: u32 = 170;
pub const __NR_setdomainname: u32 = 171;
pub const __NR_iopl: u32 = 172;
pub const __NR_ioperm: u32 = 173;
pub const __NR_create_module: u32 = 174;
pub const __NR_init_module: u32 = 175;
pub const __NR_delete_module: u32 = 176;
pub const __NR_get_kernel_syms: u32 = 177;
pub const __NR_query_module: u32 = 178;
pub const __NR_quotactl: u32 = 179;
pub const __NR_nfsservctl: u32 = 180;
pub const __NR_getpmsg: u32 = 181;
pub const __NR_putpmsg: u32 = 182;
pub const __NR_afs_syscall: u32 = 183;
pub const __NR_tuxcall: u32 = 184;
pub const __NR_security: u32 = 185;
pub const __NR_gettid: u32 = 186;
pub const __NR_readahead: u32 = 187;
pub const __NR_setxattr: u32 = 188;
pub const __NR_lsetxattr: u32 = 189;
pub const __NR_fsetxattr: u32 = 190;
pub const __NR_getxattr: u32 = 191;
pub const __NR_lgetxattr: u32 = 192;
pub const __NR_fgetxattr: u32 = 193;
pub const __NR_listxattr: u32 = 194;
pub const __NR_llistxattr: u32 = 195;
pub const __NR_flistxattr: u32 = 196;
pub const __NR_removexattr: u32 = 197;
pub const __NR_lremovexattr: u32 = 198;
pub const __NR_fremovexattr: u32 = 199;
pub const __NR_tkill: u32 = 200;
pub const __NR_time: u32 = 201;
pub const __NR_futex: u32 = 202;
pub const __NR_sched_setaffinity: u32 = 203;
pub const __NR_sched_getaffinity: u32 = 204;
pub const __NR_set_thread_area: u32 = 205;
pub const __NR_io_setup: u32 = 206;
pub const __NR_io_destroy: u32 = 207;
pub const __NR_io_getevents: u32 = 208;
pub const __NR_io_submit: u32 = 209;
pub const __NR_io_cancel: u32 = 210;
pub const __NR_get_thread_area: u32 = 211;
pub const __NR_lookup_dcookie: u32 = 212;
pub const __NR_epoll_create: u32 = 213;
pub const __NR_epoll_ctl_old: u32 = 214;
pub const __NR_epoll_wait_old: u32 = 215;
pub const __NR_remap_file_pages: u32 = 216;
pub const __NR_getdents64: u32 = 217;
pub const __NR_set_tid_address: u32 = 218;
pub const __NR_restart_syscall: u32 = 219;
pub const __NR_semtimedop: u32 = 220;
pub const __NR_fadvise64: u32 = 221;
pub const __NR_timer_create: u32 = 222;
pub const __NR_timer_settime: u32 = 223;
pub const __NR_timer_gettime: u32 = 224;
pub const __NR_timer_getoverrun: u32 = 225;
pub const __NR_timer_delete: u32 = 226;
pub const __NR_clock_settime: u32 = 227;
pub const __NR_clock_gettime: u32 = 228;
pub const __NR_clock_getres: u32 = 229;
pub const __NR_clock_nanosleep: u32 = 230;
pub const __NR_exit_group: u32 = 231;
pub const __NR_epoll_wait: u32 = 232;
pub const __NR_epoll_ctl: u32 = 233;
pub const __NR_tgkill: u32 = 234;
pub const __NR_utimes: u32 = 235;
pub const __NR_vserver: u32 = 236;
pub const __NR_mbind: u32 = 237;
pub const __NR_set_mempolicy: u32 = 238;
pub const __NR_get_mempolicy: u32 = 239;
pub const __NR_mq_open: u32 = 240;
pub const __NR_mq_unlink: u32 = 241;
pub const __NR_mq_timedsend: u32 = 242;
pub const __NR_mq_timedreceive: u32 = 243;
pub const __NR_mq_notify: u32 = 244;
pub const __NR_mq_getsetattr: u32 = 245;
pub const __NR_kexec_load: u32 = 246;
pub const __NR_waitid: u32 = 247;
pub const __NR_add_key: u32 = 248;
pub const __NR_request_key: u32 = 249;
pub const __NR_keyctl: u32 = 250;
pub const __NR_ioprio_set: u32 = 251;
pub const __NR_ioprio_get: u32 = 252;
pub const __NR_inotify_init: u32 = 253;
pub const __NR_inotify_add_watch: u32 = 254;
pub const __NR_inotify_rm_watch: u32 = 255;
pub const __NR_migrate_pages: u32 = 256;
pub const __NR_openat: u32 = 257;
pub const __NR_mkdirat: u32 = 258;
pub const __NR_mknodat: u32 = 259;
pub const __NR_fchownat: u32 = 260;
pub const __NR_futimesat: u32 = 261;
pub const __NR_newfstatat: u32 = 262;
pub const __NR_unlinkat: u32 = 263;
pub const __NR_renameat: u32 = 264;
pub const __NR_linkat: u32 = 265;
pub const __NR_symlinkat: u32 = 266;
pub const __NR_readlinkat: u32 = 267;
pub const __NR_fchmodat: u32 = 268;
pub const __NR_faccessat: u32 = 269;
pub const __NR_pselect6: u32 = 270;
pub const __NR_ppoll: u32 = 271;
pub const __NR_unshare: u32 = 272;
pub const __NR_set_robust_list: u32 = 273;
pub const __NR_get_robust_list: u32 = 274;
pub const __NR_splice: u32 = 275;
pub const __NR_tee: u32 = 276;
pub const __NR_sync_file_range: u32 = 277;
pub const __NR_vmsplice: u32 = 278;
pub const __NR_move_pages: u32 = 279;
pub const __NR_utimensat: u32 = 280;
pub const __NR_epoll_pwait: u32 = 281;
pub const __NR_signalfd: u32 = 282;
pub const __NR_timerfd_create: u32 = 283;
pub const __NR_eventfd: u32 = 284;
pub const __NR_fallocate: u32 = 285;
pub const __NR_timerfd_settime: u32 = 286;
pub const __NR_timerfd_gettime: u32 = 287;
pub const __NR_accept4: u32 = 288;
pub const __NR_signalfd4: u32 = 289;
pub const __NR_eventfd2: u32 = 290;
pub const __NR_epoll_create1: u32 = 291;
pub const __NR_dup3: u32 = 292;
pub const __NR_pipe2: u32 = 293;
pub const __NR_inotify_init1: u32 = 294;
pub const __NR_preadv: u32 = 295;
pub const __NR_pwritev: u32 = 296;
pub const __NR_rt_tgsigqueueinfo: u32 = 297;
pub const __NR_perf_event_open: u32 = 298;
pub const __NR_recvmmsg: u32 = 299;
pub const __NR_fanotify_init: u32 = 300;
pub const __NR_fanotify_mark: u32 = 301;
pub const __NR_prlimit64: u32 = 302;
pub const __NR_name_to_handle_at: u32 = 303;
pub const __NR_open_by_handle_at: u32 = 304;
pub const __NR_clock_adjtime: u32 = 305;
pub const __NR_syncfs: u32 = 306;
pub const __NR_sendmmsg: u32 = 307;
pub const __NR_setns: u32 = 308;
pub const __NR_getcpu: u32 = 309;
pub const __NR_process_vm_readv: u32 = 310;
pub const __NR_process_vm_writev: u32 = 311;
pub const __NR_kcmp: u32 = 312;
pub const __NR_finit_module: u32 = 313;
pub const __NR_sched_setattr: u32 = 314;
pub const __NR_sched_getattr: u32 = 315;
pub const __NR_renameat2: u32 = 316;
pub const __NR_seccomp: u32 = 317;
pub const __NR_getrandom: u32 = 318;
pub const __NR_memfd_create: u32 = 319;
pub const __NR_kexec_file_load: u32 = 320;
pub const __NR_bpf: u32 = 321;
pub const __NR_execveat: u32 = 322;
pub const __NR_userfaultfd: u32 = 323;
pub const __NR_membarrier: u32 = 324;
pub const __NR_mlock2: u32 = 325;
pub const __NR_copy_file_range: u32 = 326;
pub const __NR_preadv2: u32 = 327;
pub const __NR_pwritev2: u32 = 328;
pub const __NR_pkey_mprotect: u32 = 329;
pub const __NR_pkey_alloc: u32 = 330;
pub const __NR_pkey_free: u32 = 331;
pub const __NR_statx: u32 = 332;
pub const __NR_io_pgetevents: u32 = 333;
pub const __NR_rseq: u32 = 334;
pub const __NR_pidfd_send_signal: u32 = 424;
pub const __NR_io_uring_setup: u32 = 425;
pub const __NR_io_uring_enter: u32 = 426;
pub const __NR_io_uring_register: u32 = 427;
pub const __NR_open_tree: u32 = 428;
pub const __NR_move_mount: u32 = 429;
pub const __NR_fsopen: u32 = 430;
pub const __NR_fsconfig: u32 = 431;
pub const __NR_fsmount: u32 = 432;
pub const __NR_fspick: u32 = 433;
pub const __NR_pidfd_open: u32 = 434;
pub const __NR_clone3: u32 = 435;
pub const __NR_close_range: u32 = 436;
pub const __NR_openat2: u32 = 437;
pub const __NR_pidfd_getfd: u32 = 438;
pub const __NR_faccessat2: u32 = 439;
pub const __NR_process_madvise: u32 = 440;
pub const __NR_epoll_pwait2: u32 = 441;
pub const __NR_mount_setattr: u32 = 442;
pub const __NR_quotactl_fd: u32 = 443;
pub const __NR_landlock_create_ruleset: u32 = 444;
pub const __NR_landlock_add_rule: u32 = 445;
pub const __NR_landlock_restrict_self: u32 = 446;
pub const __NR_memfd_secret: u32 = 447;
pub const __NR_process_mrelease: u32 = 448;
pub const __NR_futex_waitv: u32 = 449;
pub const __NR_set_mempolicy_home_node: u32 = 450;
pub const __GLIBC_LINUX_VERSION_CODE: u32 = 331776;
pub const SYS__sysctl: u32 = 156;
pub const SYS_accept: u32 = 43;
pub const SYS_accept4: u32 = 288;
pub const SYS_access: u32 = 21;
pub const SYS_acct: u32 = 163;
pub const SYS_add_key: u32 = 248;
pub const SYS_adjtimex: u32 = 159;
pub const SYS_afs_syscall: u32 = 183;
pub const SYS_alarm: u32 = 37;
pub const SYS_arch_prctl: u32 = 158;
pub const SYS_bind: u32 = 49;
pub const SYS_bpf: u32 = 321;
pub const SYS_brk: u32 = 12;
pub const SYS_capget: u32 = 125;
pub const SYS_capset: u32 = 126;
pub const SYS_chdir: u32 = 80;
pub const SYS_chmod: u32 = 90;
pub const SYS_chown: u32 = 92;
pub const SYS_chroot: u32 = 161;
pub const SYS_clock_adjtime: u32 = 305;
pub const SYS_clock_getres: u32 = 229;
pub const SYS_clock_gettime: u32 = 228;
pub const SYS_clock_nanosleep: u32 = 230;
pub const SYS_clock_settime: u32 = 227;
pub const SYS_clone: u32 = 56;
pub const SYS_clone3: u32 = 435;
pub const SYS_close: u32 = 3;
pub const SYS_close_range: u32 = 436;
pub const SYS_connect: u32 = 42;
pub const SYS_copy_file_range: u32 = 326;
pub const SYS_creat: u32 = 85;
pub const SYS_create_module: u32 = 174;
pub const SYS_delete_module: u32 = 176;
pub const SYS_dup: u32 = 32;
pub const SYS_dup2: u32 = 33;
pub const SYS_dup3: u32 = 292;
pub const SYS_epoll_create: u32 = 213;
pub const SYS_epoll_create1: u32 = 291;
pub const SYS_epoll_ctl: u32 = 233;
pub const SYS_epoll_ctl_old: u32 = 214;
pub const SYS_epoll_pwait: u32 = 281;
pub const SYS_epoll_pwait2: u32 = 441;
pub const SYS_epoll_wait: u32 = 232;
pub const SYS_epoll_wait_old: u32 = 215;
pub const SYS_eventfd: u32 = 284;
pub const SYS_eventfd2: u32 = 290;
pub const SYS_execve: u32 = 59;
pub const SYS_execveat: u32 = 322;
pub const SYS_exit: u32 = 60;
pub const SYS_exit_group: u32 = 231;
pub const SYS_faccessat: u32 = 269;
pub const SYS_faccessat2: u32 = 439;
pub const SYS_fadvise64: u32 = 221;
pub const SYS_fallocate: u32 = 285;
pub const SYS_fanotify_init: u32 = 300;
pub const SYS_fanotify_mark: u32 = 301;
pub const SYS_fchdir: u32 = 81;
pub const SYS_fchmod: u32 = 91;
pub const SYS_fchmodat: u32 = 268;
pub const SYS_fchown: u32 = 93;
pub const SYS_fchownat: u32 = 260;
pub const SYS_fcntl: u32 = 72;
pub const SYS_fdatasync: u32 = 75;
pub const SYS_fgetxattr: u32 = 193;
pub const SYS_finit_module: u32 = 313;
pub const SYS_flistxattr: u32 = 196;
pub const SYS_flock: u32 = 73;
pub const SYS_fork: u32 = 57;
pub const SYS_fremovexattr: u32 = 199;
pub const SYS_fsconfig: u32 = 431;
pub const SYS_fsetxattr: u32 = 190;
pub const SYS_fsmount: u32 = 432;
pub const SYS_fsopen: u32 = 430;
pub const SYS_fspick: u32 = 433;
pub const SYS_fstat: u32 = 5;
pub const SYS_fstatfs: u32 = 138;
pub const SYS_fsync: u32 = 74;
pub const SYS_ftruncate: u32 = 77;
pub const SYS_futex: u32 = 202;
pub const SYS_futex_waitv: u32 = 449;
pub const SYS_futimesat: u32 = 261;
pub const SYS_get_kernel_syms: u32 = 177;
pub const SYS_get_mempolicy: u32 = 239;
pub const SYS_get_robust_list: u32 = 274;
pub const SYS_get_thread_area: u32 = 211;
pub const SYS_getcpu: u32 = 309;
pub const SYS_getcwd: u32 = 79;
pub const SYS_getdents: u32 = 78;
pub const SYS_getdents64: u32 = 217;
pub const SYS_getegid: u32 = 108;
pub const SYS_geteuid: u32 = 107;
pub const SYS_getgid: u32 = 104;
pub const SYS_getgroups: u32 = 115;
pub const SYS_getitimer: u32 = 36;
pub const SYS_getpeername: u32 = 52;
pub const SYS_getpgid: u32 = 121;
pub const SYS_getpgrp: u32 = 111;
pub const SYS_getpid: u32 = 39;
pub const SYS_getpmsg: u32 = 181;
pub const SYS_getppid: u32 = 110;
pub const SYS_getpriority: u32 = 140;
pub const SYS_getrandom: u32 = 318;
pub const SYS_getresgid: u32 = 120;
pub const SYS_getresuid: u32 = 118;
pub const SYS_getrlimit: u32 = 97;
pub const SYS_getrusage: u32 = 98;
pub const SYS_getsid: u32 = 124;
pub const SYS_getsockname: u32 = 51;
pub const SYS_getsockopt: u32 = 55;
pub const SYS_gettid: u32 = 186;
pub const SYS_gettimeofday: u32 = 96;
pub const SYS_getuid: u32 = 102;
pub const SYS_getxattr: u32 = 191;
pub const SYS_init_module: u32 = 175;
pub const SYS_inotify_add_watch: u32 = 254;
pub const SYS_inotify_init: u32 = 253;
pub const SYS_inotify_init1: u32 = 294;
pub const SYS_inotify_rm_watch: u32 = 255;
pub const SYS_io_cancel: u32 = 210;
pub const SYS_io_destroy: u32 = 207;
pub const SYS_io_getevents: u32 = 208;
pub const SYS_io_pgetevents: u32 = 333;
pub const SYS_io_setup: u32 = 206;
pub const SYS_io_submit: u32 = 209;
pub const SYS_io_uring_enter: u32 = 426;
pub const SYS_io_uring_register: u32 = 427;
pub const SYS_io_uring_setup: u32 = 425;
pub const SYS_ioctl: u32 = 16;
pub const SYS_ioperm: u32 = 173;
pub const SYS_iopl: u32 = 172;
pub const SYS_ioprio_get: u32 = 252;
pub const SYS_ioprio_set: u32 = 251;
pub const SYS_kcmp: u32 = 312;
pub const SYS_kexec_file_load: u32 = 320;
pub const SYS_kexec_load: u32 = 246;
pub const SYS_keyctl: u32 = 250;
pub const SYS_kill: u32 = 62;
pub const SYS_landlock_add_rule: u32 = 445;
pub const SYS_landlock_create_ruleset: u32 = 444;
pub const SYS_landlock_restrict_self: u32 = 446;
pub const SYS_lchown: u32 = 94;
pub const SYS_lgetxattr: u32 = 192;
pub const SYS_link: u32 = 86;
pub const SYS_linkat: u32 = 265;
pub const SYS_listen: u32 = 50;
pub const SYS_listxattr: u32 = 194;
pub const SYS_llistxattr: u32 = 195;
pub const SYS_lookup_dcookie: u32 = 212;
pub const SYS_lremovexattr: u32 = 198;
pub const SYS_lseek: u32 = 8;
pub const SYS_lsetxattr: u32 = 189;
pub const SYS_lstat: u32 = 6;
pub const SYS_madvise: u32 = 28;
pub const SYS_mbind: u32 = 237;
pub const SYS_membarrier: u32 = 324;
pub const SYS_memfd_create: u32 = 319;
pub const SYS_memfd_secret: u32 = 447;
pub const SYS_migrate_pages: u32 = 256;
pub const SYS_mincore: u32 = 27;
pub const SYS_mkdir: u32 = 83;
pub const SYS_mkdirat: u32 = 258;
pub const SYS_mknod: u32 = 133;
pub const SYS_mknodat: u32 = 259;
pub const SYS_mlock: u32 = 149;
pub const SYS_mlock2: u32 = 325;
pub const SYS_mlockall: u32 = 151;
pub const SYS_mmap: u32 = 9;
pub const SYS_modify_ldt: u32 = 154;
pub const SYS_mount: u32 = 165;
pub const SYS_mount_setattr: u32 = 442;
pub const SYS_move_mount: u32 = 429;
pub const SYS_move_pages: u32 = 279;
pub const SYS_mprotect: u32 = 10;
pub const SYS_mq_getsetattr: u32 = 245;
pub const SYS_mq_notify: u32 = 244;
pub const SYS_mq_open: u32 = 240;
pub const SYS_mq_timedreceive: u32 = 243;
pub const SYS_mq_timedsend: u32 = 242;
pub const SYS_mq_unlink: u32 = 241;
pub const SYS_mremap: u32 = 25;
pub const SYS_msgctl: u32 = 71;
pub const SYS_msgget: u32 = 68;
pub const SYS_msgrcv: u32 = 70;
pub const SYS_msgsnd: u32 = 69;
pub const SYS_msync: u32 = 26;
pub const SYS_munlock: u32 = 150;
pub const SYS_munlockall: u32 = 152;
pub const SYS_munmap: u32 = 11;
pub const SYS_name_to_handle_at: u32 = 303;
pub const SYS_nanosleep: u32 = 35;
pub const SYS_newfstatat: u32 = 262;
pub const SYS_nfsservctl: u32 = 180;
pub const SYS_open: u32 = 2;
pub const SYS_open_by_handle_at: u32 = 304;
pub const SYS_open_tree: u32 = 428;
pub const SYS_openat: u32 = 257;
pub const SYS_openat2: u32 = 437;
pub const SYS_pause: u32 = 34;
pub const SYS_perf_event_open: u32 = 298;
pub const SYS_personality: u32 = 135;
pub const SYS_pidfd_getfd: u32 = 438;
pub const SYS_pidfd_open: u32 = 434;
pub const SYS_pidfd_send_signal: u32 = 424;
pub const SYS_pipe: u32 = 22;
pub const SYS_pipe2: u32 = 293;
pub const SYS_pivot_root: u32 = 155;
pub const SYS_pkey_alloc: u32 = 330;
pub const SYS_pkey_free: u32 = 331;
pub const SYS_pkey_mprotect: u32 = 329;
pub const SYS_poll: u32 = 7;
pub const SYS_ppoll: u32 = 271;
pub const SYS_prctl: u32 = 157;
pub const SYS_pread64: u32 = 17;
pub const SYS_preadv: u32 = 295;
pub const SYS_preadv2: u32 = 327;
pub const SYS_prlimit64: u32 = 302;
pub const SYS_process_madvise: u32 = 440;
pub const SYS_process_mrelease: u32 = 448;
pub const SYS_process_vm_readv: u32 = 310;
pub const SYS_process_vm_writev: u32 = 311;
pub const SYS_pselect6: u32 = 270;
pub const SYS_ptrace: u32 = 101;
pub const SYS_putpmsg: u32 = 182;
pub const SYS_pwrite64: u32 = 18;
pub const SYS_pwritev: u32 = 296;
pub const SYS_pwritev2: u32 = 328;
pub const SYS_query_module: u32 = 178;
pub const SYS_quotactl: u32 = 179;
pub const SYS_quotactl_fd: u32 = 443;
pub const SYS_read: u32 = 0;
pub const SYS_readahead: u32 = 187;
pub const SYS_readlink: u32 = 89;
pub const SYS_readlinkat: u32 = 267;
pub const SYS_readv: u32 = 19;
pub const SYS_reboot: u32 = 169;
pub const SYS_recvfrom: u32 = 45;
pub const SYS_recvmmsg: u32 = 299;
pub const SYS_recvmsg: u32 = 47;
pub const SYS_remap_file_pages: u32 = 216;
pub const SYS_removexattr: u32 = 197;
pub const SYS_rename: u32 = 82;
pub const SYS_renameat: u32 = 264;
pub const SYS_renameat2: u32 = 316;
pub const SYS_request_key: u32 = 249;
pub const SYS_restart_syscall: u32 = 219;
pub const SYS_rmdir: u32 = 84;
pub const SYS_rseq: u32 = 334;
pub const SYS_rt_sigaction: u32 = 13;
pub const SYS_rt_sigpending: u32 = 127;
pub const SYS_rt_sigprocmask: u32 = 14;
pub const SYS_rt_sigqueueinfo: u32 = 129;
pub const SYS_rt_sigreturn: u32 = 15;
pub const SYS_rt_sigsuspend: u32 = 130;
pub const SYS_rt_sigtimedwait: u32 = 128;
pub const SYS_rt_tgsigqueueinfo: u32 = 297;
pub const SYS_sched_get_priority_max: u32 = 146;
pub const SYS_sched_get_priority_min: u32 = 147;
pub const SYS_sched_getaffinity: u32 = 204;
pub const SYS_sched_getattr: u32 = 315;
pub const SYS_sched_getparam: u32 = 143;
pub const SYS_sched_getscheduler: u32 = 145;
pub const SYS_sched_rr_get_interval: u32 = 148;
pub const SYS_sched_setaffinity: u32 = 203;
pub const SYS_sched_setattr: u32 = 314;
pub const SYS_sched_setparam: u32 = 142;
pub const SYS_sched_setscheduler: u32 = 144;
pub const SYS_sched_yield: u32 = 24;
pub const SYS_seccomp: u32 = 317;
pub const SYS_security: u32 = 185;
pub const SYS_select: u32 = 23;
pub const SYS_semctl: u32 = 66;
pub const SYS_semget: u32 = 64;
pub const SYS_semop: u32 = 65;
pub const SYS_semtimedop: u32 = 220;
pub const SYS_sendfile: u32 = 40;
pub const SYS_sendmmsg: u32 = 307;
pub const SYS_sendmsg: u32 = 46;
pub const SYS_sendto: u32 = 44;
pub const SYS_set_mempolicy: u32 = 238;
pub const SYS_set_robust_list: u32 = 273;
pub const SYS_set_thread_area: u32 = 205;
pub const SYS_set_tid_address: u32 = 218;
pub const SYS_setdomainname: u32 = 171;
pub const SYS_setfsgid: u32 = 123;
pub const SYS_setfsuid: u32 = 122;
pub const SYS_setgid: u32 = 106;
pub const SYS_setgroups: u32 = 116;
pub const SYS_sethostname: u32 = 170;
pub const SYS_setitimer: u32 = 38;
pub const SYS_setns: u32 = 308;
pub const SYS_setpgid: u32 = 109;
pub const SYS_setpriority: u32 = 141;
pub const SYS_setregid: u32 = 114;
pub const SYS_setresgid: u32 = 119;
pub const SYS_setresuid: u32 = 117;
pub const SYS_setreuid: u32 = 113;
pub const SYS_setrlimit: u32 = 160;
pub const SYS_setsid: u32 = 112;
pub const SYS_setsockopt: u32 = 54;
pub const SYS_settimeofday: u32 = 164;
pub const SYS_setuid: u32 = 105;
pub const SYS_setxattr: u32 = 188;
pub const SYS_shmat: u32 = 30;
pub const SYS_shmctl: u32 = 31;
pub const SYS_shmdt: u32 = 67;
pub const SYS_shmget: u32 = 29;
pub const SYS_shutdown: u32 = 48;
pub const SYS_sigaltstack: u32 = 131;
pub const SYS_signalfd: u32 = 282;
pub const SYS_signalfd4: u32 = 289;
pub const SYS_socket: u32 = 41;
pub const SYS_socketpair: u32 = 53;
pub const SYS_splice: u32 = 275;
pub const SYS_stat: u32 = 4;
pub const SYS_statfs: u32 = 137;
pub const SYS_statx: u32 = 332;
pub const SYS_swapoff: u32 = 168;
pub const SYS_swapon: u32 = 167;
pub const SYS_symlink: u32 = 88;
pub const SYS_symlinkat: u32 = 266;
pub const SYS_sync: u32 = 162;
pub const SYS_sync_file_range: u32 = 277;
pub const SYS_syncfs: u32 = 306;
pub const SYS_sysfs: u32 = 139;
pub const SYS_sysinfo: u32 = 99;
pub const SYS_syslog: u32 = 103;
pub const SYS_tee: u32 = 276;
pub const SYS_tgkill: u32 = 234;
pub const SYS_time: u32 = 201;
pub const SYS_timer_create: u32 = 222;
pub const SYS_timer_delete: u32 = 226;
pub const SYS_timer_getoverrun: u32 = 225;
pub const SYS_timer_gettime: u32 = 224;
pub const SYS_timer_settime: u32 = 223;
pub const SYS_timerfd_create: u32 = 283;
pub const SYS_timerfd_gettime: u32 = 287;
pub const SYS_timerfd_settime: u32 = 286;
pub const SYS_times: u32 = 100;
pub const SYS_tkill: u32 = 200;
pub const SYS_truncate: u32 = 76;
pub const SYS_tuxcall: u32 = 184;
pub const SYS_umask: u32 = 95;
pub const SYS_umount2: u32 = 166;
pub const SYS_uname: u32 = 63;
pub const SYS_unlink: u32 = 87;
pub const SYS_unlinkat: u32 = 263;
pub const SYS_unshare: u32 = 272;
pub const SYS_uselib: u32 = 134;
pub const SYS_userfaultfd: u32 = 323;
pub const SYS_ustat: u32 = 136;
pub const SYS_utime: u32 = 132;
pub const SYS_utimensat: u32 = 280;
pub const SYS_utimes: u32 = 235;
pub const SYS_vfork: u32 = 58;
pub const SYS_vhangup: u32 = 153;
pub const SYS_vmsplice: u32 = 278;
pub const SYS_vserver: u32 = 236;
pub const SYS_wait4: u32 = 61;
pub const SYS_waitid: u32 = 247;
pub const SYS_write: u32 = 1;
pub const SYS_writev: u32 = 20;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const FSCRYPT_POLICY_FLAGS_PAD_4: u32 = 0;
pub const FSCRYPT_POLICY_FLAGS_PAD_8: u32 = 1;
pub const FSCRYPT_POLICY_FLAGS_PAD_16: u32 = 2;
pub const FSCRYPT_POLICY_FLAGS_PAD_32: u32 = 3;
pub const FSCRYPT_POLICY_FLAGS_PAD_MASK: u32 = 3;
pub const FSCRYPT_POLICY_FLAG_DIRECT_KEY: u32 = 4;
pub const FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64: u32 = 8;
pub const FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32: u32 = 16;
pub const FSCRYPT_MODE_AES_256_XTS: u32 = 1;
pub const FSCRYPT_MODE_AES_256_CTS: u32 = 4;
pub const FSCRYPT_MODE_AES_128_CBC: u32 = 5;
pub const FSCRYPT_MODE_AES_128_CTS: u32 = 6;
pub const FSCRYPT_MODE_SM4_XTS: u32 = 7;
pub const FSCRYPT_MODE_SM4_CTS: u32 = 8;
pub const FSCRYPT_MODE_ADIANTUM: u32 = 9;
pub const FSCRYPT_MODE_AES_256_HCTR2: u32 = 10;
pub const FSCRYPT_POLICY_V1: u32 = 0;
pub const FSCRYPT_KEY_DESCRIPTOR_SIZE: u32 = 8;
pub const FSCRYPT_KEY_DESC_PREFIX: &'static [u8; 9usize] = b"fscrypt:\0";
pub const FSCRYPT_KEY_DESC_PREFIX_SIZE: u32 = 8;
pub const FSCRYPT_MAX_KEY_SIZE: u32 = 64;
pub const FSCRYPT_POLICY_V2: u32 = 2;
pub const FSCRYPT_KEY_IDENTIFIER_SIZE: u32 = 16;
pub const FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR: u32 = 1;
pub const FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER: u32 = 2;
pub const FSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY: u32 = 1;
pub const FSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS: u32 = 2;
pub const FSCRYPT_KEY_STATUS_ABSENT: u32 = 1;
pub const FSCRYPT_KEY_STATUS_PRESENT: u32 = 2;
pub const FSCRYPT_KEY_STATUS_INCOMPLETELY_REMOVED: u32 = 3;
pub const FSCRYPT_KEY_STATUS_FLAG_ADDED_BY_SELF: u32 = 1;
pub const FS_KEY_DESCRIPTOR_SIZE: u32 = 8;
pub const FS_POLICY_FLAGS_PAD_4: u32 = 0;
pub const FS_POLICY_FLAGS_PAD_8: u32 = 1;
pub const FS_POLICY_FLAGS_PAD_16: u32 = 2;
pub const FS_POLICY_FLAGS_PAD_32: u32 = 3;
pub const FS_POLICY_FLAGS_PAD_MASK: u32 = 3;
pub const FS_POLICY_FLAG_DIRECT_KEY: u32 = 4;
pub const FS_POLICY_FLAGS_VALID: u32 = 7;
pub const FS_ENCRYPTION_MODE_INVALID: u32 = 0;
pub const FS_ENCRYPTION_MODE_AES_256_XTS: u32 = 1;
pub const FS_ENCRYPTION_MODE_AES_256_GCM: u32 = 2;
pub const FS_ENCRYPTION_MODE_AES_256_CBC: u32 = 3;
pub const FS_ENCRYPTION_MODE_AES_256_CTS: u32 = 4;
pub const FS_ENCRYPTION_MODE_AES_128_CBC: u32 = 5;
pub const FS_ENCRYPTION_MODE_AES_128_CTS: u32 = 6;
pub const FS_ENCRYPTION_MODE_ADIANTUM: u32 = 9;
pub const FS_KEY_DESC_PREFIX: &'static [u8; 9usize] = b"fscrypt:\0";
pub const FS_KEY_DESC_PREFIX_SIZE: u32 = 8;
pub const FS_MAX_KEY_SIZE: u32 = 64;
pub const MS_RDONLY: u32 = 1;
pub const MS_NOSUID: u32 = 2;
pub const MS_NODEV: u32 = 4;
pub const MS_NOEXEC: u32 = 8;
pub const MS_SYNCHRONOUS: u32 = 16;
pub const MS_REMOUNT: u32 = 32;
pub const MS_MANDLOCK: u32 = 64;
pub const MS_DIRSYNC: u32 = 128;
pub const MS_NOSYMFOLLOW: u32 = 256;
pub const MS_NOATIME: u32 = 1024;
pub const MS_NODIRATIME: u32 = 2048;
pub const MS_BIND: u32 = 4096;
pub const MS_MOVE: u32 = 8192;
pub const MS_REC: u32 = 16384;
pub const MS_VERBOSE: u32 = 32768;
pub const MS_SILENT: u32 = 32768;
pub const MS_POSIXACL: u32 = 65536;
pub const MS_UNBINDABLE: u32 = 131072;
pub const MS_PRIVATE: u32 = 262144;
pub const MS_SLAVE: u32 = 524288;
pub const MS_SHARED: u32 = 1048576;
pub const MS_RELATIME: u32 = 2097152;
pub const MS_KERNMOUNT: u32 = 4194304;
pub const MS_I_VERSION: u32 = 8388608;
pub const MS_STRICTATIME: u32 = 16777216;
pub const MS_LAZYTIME: u32 = 33554432;
pub const MS_SUBMOUNT: u32 = 67108864;
pub const MS_NOREMOTELOCK: u32 = 134217728;
pub const MS_NOSEC: u32 = 268435456;
pub const MS_BORN: u32 = 536870912;
pub const MS_ACTIVE: u32 = 1073741824;
pub const MS_NOUSER: u32 = 2147483648;
pub const MS_RMT_MASK: u32 = 41943121;
pub const MS_MGC_VAL: u32 = 3236757504;
pub const MS_MGC_MSK: u32 = 4294901760;
pub const OPEN_TREE_CLONE: u32 = 1;
pub const MOVE_MOUNT_F_SYMLINKS: u32 = 1;
pub const MOVE_MOUNT_F_AUTOMOUNTS: u32 = 2;
pub const MOVE_MOUNT_F_EMPTY_PATH: u32 = 4;
pub const MOVE_MOUNT_T_SYMLINKS: u32 = 16;
pub const MOVE_MOUNT_T_AUTOMOUNTS: u32 = 32;
pub const MOVE_MOUNT_T_EMPTY_PATH: u32 = 64;
pub const MOVE_MOUNT_SET_GROUP: u32 = 256;
pub const MOVE_MOUNT__MASK: u32 = 375;
pub const FSOPEN_CLOEXEC: u32 = 1;
pub const FSPICK_CLOEXEC: u32 = 1;
pub const FSPICK_SYMLINK_NOFOLLOW: u32 = 2;
pub const FSPICK_NO_AUTOMOUNT: u32 = 4;
pub const FSPICK_EMPTY_PATH: u32 = 8;
pub const FSMOUNT_CLOEXEC: u32 = 1;
pub const MOUNT_ATTR_RDONLY: u32 = 1;
pub const MOUNT_ATTR_NOSUID: u32 = 2;
pub const MOUNT_ATTR_NODEV: u32 = 4;
pub const MOUNT_ATTR_NOEXEC: u32 = 8;
pub const MOUNT_ATTR__ATIME: u32 = 112;
pub const MOUNT_ATTR_RELATIME: u32 = 0;
pub const MOUNT_ATTR_NOATIME: u32 = 16;
pub const MOUNT_ATTR_STRICTATIME: u32 = 32;
pub const MOUNT_ATTR_NODIRATIME: u32 = 128;
pub const MOUNT_ATTR_IDMAP: u32 = 1048576;
pub const MOUNT_ATTR_NOSYMFOLLOW: u32 = 2097152;
pub const MOUNT_ATTR_SIZE_VER0: u32 = 32;
pub const INR_OPEN_CUR: u32 = 1024;
pub const INR_OPEN_MAX: u32 = 4096;
pub const BLOCK_SIZE_BITS: u32 = 10;
pub const BLOCK_SIZE: u32 = 1024;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const SEEK_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const FILE_DEDUPE_RANGE_SAME: u32 = 0;
pub const FILE_DEDUPE_RANGE_DIFFERS: u32 = 1;
pub const NR_FILE: u32 = 8192;
pub const FS_XFLAG_REALTIME: u32 = 1;
pub const FS_XFLAG_PREALLOC: u32 = 2;
pub const FS_XFLAG_IMMUTABLE: u32 = 8;
pub const FS_XFLAG_APPEND: u32 = 16;
pub const FS_XFLAG_SYNC: u32 = 32;
pub const FS_XFLAG_NOATIME: u32 = 64;
pub const FS_XFLAG_NODUMP: u32 = 128;
pub const FS_XFLAG_RTINHERIT: u32 = 256;
pub const FS_XFLAG_PROJINHERIT: u32 = 512;
pub const FS_XFLAG_NOSYMLINKS: u32 = 1024;
pub const FS_XFLAG_EXTSIZE: u32 = 2048;
pub const FS_XFLAG_EXTSZINHERIT: u32 = 4096;
pub const FS_XFLAG_NODEFRAG: u32 = 8192;
pub const FS_XFLAG_FILESTREAM: u32 = 16384;
pub const FS_XFLAG_DAX: u32 = 32768;
pub const FS_XFLAG_COWEXTSIZE: u32 = 65536;
pub const FS_XFLAG_HASATTR: u32 = 2147483648;
pub const BMAP_IOCTL: u32 = 1;
pub const FSLABEL_MAX: u32 = 256;
pub const FS_SECRM_FL: u32 = 1;
pub const FS_UNRM_FL: u32 = 2;
pub const FS_COMPR_FL: u32 = 4;
pub const FS_SYNC_FL: u32 = 8;
pub const FS_IMMUTABLE_FL: u32 = 16;
pub const FS_APPEND_FL: u32 = 32;
pub const FS_NODUMP_FL: u32 = 64;
pub const FS_NOATIME_FL: u32 = 128;
pub const FS_DIRTY_FL: u32 = 256;
pub const FS_COMPRBLK_FL: u32 = 512;
pub const FS_NOCOMP_FL: u32 = 1024;
pub const FS_ENCRYPT_FL: u32 = 2048;
pub const FS_BTREE_FL: u32 = 4096;
pub const FS_INDEX_FL: u32 = 4096;
pub const FS_IMAGIC_FL: u32 = 8192;
pub const FS_JOURNAL_DATA_FL: u32 = 16384;
pub const FS_NOTAIL_FL: u32 = 32768;
pub const FS_DIRSYNC_FL: u32 = 65536;
pub const FS_TOPDIR_FL: u32 = 131072;
pub const FS_HUGE_FILE_FL: u32 = 262144;
pub const FS_EXTENT_FL: u32 = 524288;
pub const FS_VERITY_FL: u32 = 1048576;
pub const FS_EA_INODE_FL: u32 = 2097152;
pub const FS_EOFBLOCKS_FL: u32 = 4194304;
pub const FS_NOCOW_FL: u32 = 8388608;
pub const FS_DAX_FL: u32 = 33554432;
pub const FS_INLINE_DATA_FL: u32 = 268435456;
pub const FS_PROJINHERIT_FL: u32 = 536870912;
pub const FS_CASEFOLD_FL: u32 = 1073741824;
pub const FS_RESERVED_FL: u32 = 2147483648;
pub const FS_FL_USER_VISIBLE: u32 = 253951;
pub const FS_FL_USER_MODIFIABLE: u32 = 229631;
pub const SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const SYNC_FILE_RANGE_WRITE_AND_WAIT: u32 = 7;
pub const BTRFS_IOCTL_MAGIC: u32 = 148;
pub const BTRFS_VOL_NAME_MAX: u32 = 255;
pub const BTRFS_LABEL_SIZE: u32 = 256;
pub const BTRFS_PATH_NAME_MAX: u32 = 4087;
pub const BTRFS_DEVICE_PATH_NAME_MAX: u32 = 1024;
pub const BTRFS_SUBVOL_NAME_MAX: u32 = 4039;
pub const BTRFS_SUBVOL_CREATE_ASYNC: u32 = 1;
pub const BTRFS_SUBVOL_RDONLY: u32 = 2;
pub const BTRFS_SUBVOL_QGROUP_INHERIT: u32 = 4;
pub const BTRFS_DEVICE_SPEC_BY_ID: u32 = 8;
pub const BTRFS_SUBVOL_SPEC_BY_ID: u32 = 16;
pub const BTRFS_VOL_ARG_V2_FLAGS_SUPPORTED: u32 = 30;
pub const BTRFS_FSID_SIZE: u32 = 16;
pub const BTRFS_UUID_SIZE: u32 = 16;
pub const BTRFS_UUID_UNPARSED_SIZE: u32 = 37;
pub const BTRFS_QGROUP_LIMIT_MAX_RFER: u32 = 1;
pub const BTRFS_QGROUP_LIMIT_MAX_EXCL: u32 = 2;
pub const BTRFS_QGROUP_LIMIT_RSV_RFER: u32 = 4;
pub const BTRFS_QGROUP_LIMIT_RSV_EXCL: u32 = 8;
pub const BTRFS_QGROUP_LIMIT_RFER_CMPR: u32 = 16;
pub const BTRFS_QGROUP_LIMIT_EXCL_CMPR: u32 = 32;
pub const BTRFS_QGROUP_INHERIT_SET_LIMITS: u32 = 1;
pub const BTRFS_DEVICE_REMOVE_ARGS_MASK: u32 = 8;
pub const BTRFS_SUBVOL_CREATE_ARGS_MASK: u32 = 6;
pub const BTRFS_SUBVOL_DELETE_ARGS_MASK: u32 = 16;
pub const BTRFS_SCRUB_READONLY: u32 = 1;
pub const BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS: u32 = 0;
pub const BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID: u32 = 1;
pub const BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED: u32 = 0;
pub const BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED: u32 = 1;
pub const BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED: u32 = 2;
pub const BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED: u32 = 3;
pub const BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED: u32 = 4;
pub const BTRFS_IOCTL_DEV_REPLACE_CMD_START: u32 = 0;
pub const BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS: u32 = 1;
pub const BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL: u32 = 2;
pub const BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR: u32 = 0;
pub const BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED: u32 = 1;
pub const BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED: u32 = 2;
pub const BTRFS_IOCTL_DEV_REPLACE_RESULT_SCRUB_INPROGRESS: u32 = 3;
pub const BTRFS_FS_INFO_FLAG_CSUM_INFO: u32 = 1;
pub const BTRFS_FS_INFO_FLAG_GENERATION: u32 = 2;
pub const BTRFS_FS_INFO_FLAG_METADATA_UUID: u32 = 4;
pub const BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE: u32 = 1;
pub const BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE_VALID: u32 = 2;
pub const BTRFS_FEATURE_COMPAT_RO_VERITY: u32 = 4;
pub const BTRFS_FEATURE_COMPAT_RO_BLOCK_GROUP_TREE: u32 = 8;
pub const BTRFS_FEATURE_INCOMPAT_MIXED_BACKREF: u32 = 1;
pub const BTRFS_FEATURE_INCOMPAT_DEFAULT_SUBVOL: u32 = 2;
pub const BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS: u32 = 4;
pub const BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO: u32 = 8;
pub const BTRFS_FEATURE_INCOMPAT_COMPRESS_ZSTD: u32 = 16;
pub const BTRFS_FEATURE_INCOMPAT_BIG_METADATA: u32 = 32;
pub const BTRFS_FEATURE_INCOMPAT_EXTENDED_IREF: u32 = 64;
pub const BTRFS_FEATURE_INCOMPAT_RAID56: u32 = 128;
pub const BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA: u32 = 256;
pub const BTRFS_FEATURE_INCOMPAT_NO_HOLES: u32 = 512;
pub const BTRFS_FEATURE_INCOMPAT_METADATA_UUID: u32 = 1024;
pub const BTRFS_FEATURE_INCOMPAT_RAID1C34: u32 = 2048;
pub const BTRFS_FEATURE_INCOMPAT_ZONED: u32 = 4096;
pub const BTRFS_FEATURE_INCOMPAT_EXTENT_TREE_V2: u32 = 8192;
pub const BTRFS_BALANCE_CTL_PAUSE: u32 = 1;
pub const BTRFS_BALANCE_CTL_CANCEL: u32 = 2;
pub const BTRFS_BALANCE_DATA: u32 = 1;
pub const BTRFS_BALANCE_SYSTEM: u32 = 2;
pub const BTRFS_BALANCE_METADATA: u32 = 4;
pub const BTRFS_BALANCE_TYPE_MASK: u32 = 7;
pub const BTRFS_BALANCE_FORCE: u32 = 8;
pub const BTRFS_BALANCE_RESUME: u32 = 16;
pub const BTRFS_BALANCE_ARGS_PROFILES: u32 = 1;
pub const BTRFS_BALANCE_ARGS_USAGE: u32 = 2;
pub const BTRFS_BALANCE_ARGS_DEVID: u32 = 4;
pub const BTRFS_BALANCE_ARGS_DRANGE: u32 = 8;
pub const BTRFS_BALANCE_ARGS_VRANGE: u32 = 16;
pub const BTRFS_BALANCE_ARGS_LIMIT: u32 = 32;
pub const BTRFS_BALANCE_ARGS_LIMIT_RANGE: u32 = 64;
pub const BTRFS_BALANCE_ARGS_STRIPES_RANGE: u32 = 128;
pub const BTRFS_BALANCE_ARGS_USAGE_RANGE: u32 = 1024;
pub const BTRFS_BALANCE_ARGS_MASK: u32 = 1279;
pub const BTRFS_BALANCE_ARGS_CONVERT: u32 = 256;
pub const BTRFS_BALANCE_ARGS_SOFT: u32 = 512;
pub const BTRFS_BALANCE_STATE_RUNNING: u32 = 1;
pub const BTRFS_BALANCE_STATE_PAUSE_REQ: u32 = 2;
pub const BTRFS_BALANCE_STATE_CANCEL_REQ: u32 = 4;
pub const BTRFS_INO_LOOKUP_PATH_MAX: u32 = 4080;
pub const BTRFS_INO_LOOKUP_USER_PATH_MAX: u32 = 3824;
pub const BTRFS_DEFRAG_RANGE_COMPRESS: u32 = 1;
pub const BTRFS_DEFRAG_RANGE_START_IO: u32 = 2;
pub const BTRFS_SAME_DATA_DIFFERS: u32 = 1;
pub const BTRFS_LOGICAL_INO_ARGS_IGNORE_OFFSET: u32 = 1;
pub const BTRFS_DEV_STATS_RESET: u32 = 1;
pub const BTRFS_QUOTA_CTL_ENABLE: u32 = 1;
pub const BTRFS_QUOTA_CTL_DISABLE: u32 = 2;
pub const BTRFS_QUOTA_CTL_RESCAN__NOTUSED: u32 = 3;
pub const BTRFS_SEND_FLAG_NO_FILE_DATA: u32 = 1;
pub const BTRFS_SEND_FLAG_OMIT_STREAM_HEADER: u32 = 2;
pub const BTRFS_SEND_FLAG_OMIT_END_CMD: u32 = 4;
pub const BTRFS_SEND_FLAG_VERSION: u32 = 8;
pub const BTRFS_SEND_FLAG_COMPRESSED: u32 = 16;
pub const BTRFS_SEND_FLAG_MASK: u32 = 31;
pub const BTRFS_MAX_ROOTREF_BUFFER_NUM: u32 = 255;
pub const BTRFS_ENCODED_IO_COMPRESSION_NONE: u32 = 0;
pub const BTRFS_ENCODED_IO_COMPRESSION_ZLIB: u32 = 1;
pub const BTRFS_ENCODED_IO_COMPRESSION_ZSTD: u32 = 2;
pub const BTRFS_ENCODED_IO_COMPRESSION_LZO_4K: u32 = 3;
pub const BTRFS_ENCODED_IO_COMPRESSION_LZO_8K: u32 = 4;
pub const BTRFS_ENCODED_IO_COMPRESSION_LZO_16K: u32 = 5;
pub const BTRFS_ENCODED_IO_COMPRESSION_LZO_32K: u32 = 6;
pub const BTRFS_ENCODED_IO_COMPRESSION_LZO_64K: u32 = 7;
pub const BTRFS_ENCODED_IO_COMPRESSION_TYPES: u32 = 8;
pub const BTRFS_ENCODED_IO_ENCRYPTION_NONE: u32 = 0;
pub const BTRFS_ENCODED_IO_ENCRYPTION_TYPES: u32 = 1;
pub const _LINUX_CAPABILITY_VERSION_1: u32 = 429392688;
pub const _LINUX_CAPABILITY_U32S_1: u32 = 1;
pub const _LINUX_CAPABILITY_VERSION_2: u32 = 537333798;
pub const _LINUX_CAPABILITY_U32S_2: u32 = 2;
pub const _LINUX_CAPABILITY_VERSION_3: u32 = 537396514;
pub const _LINUX_CAPABILITY_U32S_3: u32 = 2;
pub const VFS_CAP_REVISION_MASK: u32 = 4278190080;
pub const VFS_CAP_REVISION_SHIFT: u32 = 24;
pub const VFS_CAP_FLAGS_MASK: i64 = -4278190081;
pub const VFS_CAP_FLAGS_EFFECTIVE: u32 = 1;
pub const VFS_CAP_REVISION_1: u32 = 16777216;
pub const VFS_CAP_U32_1: u32 = 1;
pub const VFS_CAP_REVISION_2: u32 = 33554432;
pub const VFS_CAP_U32_2: u32 = 2;
pub const VFS_CAP_REVISION_3: u32 = 50331648;
pub const VFS_CAP_U32_3: u32 = 2;
pub const VFS_CAP_U32: u32 = 2;
pub const VFS_CAP_REVISION: u32 = 50331648;
pub const _LINUX_CAPABILITY_VERSION: u32 = 429392688;
pub const _LINUX_CAPABILITY_U32S: u32 = 1;
pub const CAP_CHOWN: u32 = 0;
pub const CAP_DAC_OVERRIDE: u32 = 1;
pub const CAP_DAC_READ_SEARCH: u32 = 2;
pub const CAP_FOWNER: u32 = 3;
pub const CAP_FSETID: u32 = 4;
pub const CAP_KILL: u32 = 5;
pub const CAP_SETGID: u32 = 6;
pub const CAP_SETUID: u32 = 7;
pub const CAP_SETPCAP: u32 = 8;
pub const CAP_LINUX_IMMUTABLE: u32 = 9;
pub const CAP_NET_BIND_SERVICE: u32 = 10;
pub const CAP_NET_BROADCAST: u32 = 11;
pub const CAP_NET_ADMIN: u32 = 12;
pub const CAP_NET_RAW: u32 = 13;
pub const CAP_IPC_LOCK: u32 = 14;
pub const CAP_IPC_OWNER: u32 = 15;
pub const CAP_SYS_MODULE: u32 = 16;
pub const CAP_SYS_RAWIO: u32 = 17;
pub const CAP_SYS_CHROOT: u32 = 18;
pub const CAP_SYS_PTRACE: u32 = 19;
pub const CAP_SYS_PACCT: u32 = 20;
pub const CAP_SYS_ADMIN: u32 = 21;
pub const CAP_SYS_BOOT: u32 = 22;
pub const CAP_SYS_NICE: u32 = 23;
pub const CAP_SYS_RESOURCE: u32 = 24;
pub const CAP_SYS_TIME: u32 = 25;
pub const CAP_SYS_TTY_CONFIG: u32 = 26;
pub const CAP_MKNOD: u32 = 27;
pub const CAP_LEASE: u32 = 28;
pub const CAP_AUDIT_WRITE: u32 = 29;
pub const CAP_AUDIT_CONTROL: u32 = 30;
pub const CAP_SETFCAP: u32 = 31;
pub const CAP_MAC_OVERRIDE: u32 = 32;
pub const CAP_MAC_ADMIN: u32 = 33;
pub const CAP_SYSLOG: u32 = 34;
pub const CAP_WAKE_ALARM: u32 = 35;
pub const CAP_BLOCK_SUSPEND: u32 = 36;
pub const CAP_AUDIT_READ: u32 = 37;
pub const CAP_PERFMON: u32 = 38;
pub const CAP_BPF: u32 = 39;
pub const CAP_CHECKPOINT_RESTORE: u32 = 40;
pub const CAP_LAST_CAP: u32 = 40;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_policy_v1 {
    pub version: __u8,
    pub contents_encryption_mode: __u8,
    pub filenames_encryption_mode: __u8,
    pub flags: __u8,
    pub master_key_descriptor: [__u8; 8usize],
}
#[test]
fn bindgen_test_layout_fscrypt_policy_v1() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_policy_v1>(),
        12usize,
        concat!("Size of: ", stringify!(fscrypt_policy_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_policy_v1>(),
        1usize,
        concat!("Alignment of ", stringify!(fscrypt_policy_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_policy_v1>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_policy_v1>())).contents_encryption_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v1),
            "::",
            stringify!(contents_encryption_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_policy_v1>())).filenames_encryption_mode as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v1),
            "::",
            stringify!(filenames_encryption_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_policy_v1>())).flags as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_policy_v1>())).master_key_descriptor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v1),
            "::",
            stringify!(master_key_descriptor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_key {
    pub mode: __u32,
    pub raw: [__u8; 64usize],
    pub size: __u32,
}
#[test]
fn bindgen_test_layout_fscrypt_key() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_key>(),
        72usize,
        concat!("Size of: ", stringify!(fscrypt_key))
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_key>(),
        4usize,
        concat!("Alignment of ", stringify!(fscrypt_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_key>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_key),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_key>())).raw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_key),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_key>())).size as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_key),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_policy_v2 {
    pub version: __u8,
    pub contents_encryption_mode: __u8,
    pub filenames_encryption_mode: __u8,
    pub flags: __u8,
    pub __reserved: [__u8; 4usize],
    pub master_key_identifier: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_fscrypt_policy_v2() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_policy_v2>(),
        24usize,
        concat!("Size of: ", stringify!(fscrypt_policy_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_policy_v2>(),
        1usize,
        concat!("Alignment of ", stringify!(fscrypt_policy_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_policy_v2>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_policy_v2>())).contents_encryption_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v2),
            "::",
            stringify!(contents_encryption_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_policy_v2>())).filenames_encryption_mode as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v2),
            "::",
            stringify!(filenames_encryption_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_policy_v2>())).flags as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_policy_v2>())).__reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v2),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_policy_v2>())).master_key_identifier as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_policy_v2),
            "::",
            stringify!(master_key_identifier)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_get_policy_ex_arg {
    pub policy_size: __u64,
    pub policy: fscrypt_get_policy_ex_arg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fscrypt_get_policy_ex_arg__bindgen_ty_1 {
    pub version: __u8,
    pub v1: fscrypt_policy_v1,
    pub v2: fscrypt_policy_v2,
    _bindgen_union_align: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_fscrypt_get_policy_ex_arg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_get_policy_ex_arg__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(fscrypt_get_policy_ex_arg__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_get_policy_ex_arg__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(fscrypt_get_policy_ex_arg__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_policy_ex_arg__bindgen_ty_1>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_policy_ex_arg__bindgen_ty_1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_policy_ex_arg__bindgen_ty_1>())).v1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_policy_ex_arg__bindgen_ty_1),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_policy_ex_arg__bindgen_ty_1>())).v2 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_policy_ex_arg__bindgen_ty_1),
            "::",
            stringify!(v2)
        )
    );
}
#[test]
fn bindgen_test_layout_fscrypt_get_policy_ex_arg() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_get_policy_ex_arg>(),
        32usize,
        concat!("Size of: ", stringify!(fscrypt_get_policy_ex_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_get_policy_ex_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(fscrypt_get_policy_ex_arg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_policy_ex_arg>())).policy_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_policy_ex_arg),
            "::",
            stringify!(policy_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_policy_ex_arg>())).policy as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_policy_ex_arg),
            "::",
            stringify!(policy)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_key_specifier {
    pub type_: __u32,
    pub __reserved: __u32,
    pub u: fscrypt_key_specifier__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fscrypt_key_specifier__bindgen_ty_1 {
    pub __reserved: [__u8; 32usize],
    pub descriptor: [__u8; 8usize],
    pub identifier: [__u8; 16usize],
    _bindgen_union_align: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_fscrypt_key_specifier__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_key_specifier__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(fscrypt_key_specifier__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_key_specifier__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(fscrypt_key_specifier__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_key_specifier__bindgen_ty_1>())).__reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_key_specifier__bindgen_ty_1),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_key_specifier__bindgen_ty_1>())).descriptor as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_key_specifier__bindgen_ty_1),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_key_specifier__bindgen_ty_1>())).identifier as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_key_specifier__bindgen_ty_1),
            "::",
            stringify!(identifier)
        )
    );
}
#[test]
fn bindgen_test_layout_fscrypt_key_specifier() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_key_specifier>(),
        40usize,
        concat!("Size of: ", stringify!(fscrypt_key_specifier))
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_key_specifier>(),
        4usize,
        concat!("Alignment of ", stringify!(fscrypt_key_specifier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_key_specifier>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_key_specifier),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_key_specifier>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_key_specifier),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_key_specifier>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_key_specifier),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct fscrypt_provisioning_key_payload {
    pub type_: __u32,
    pub __reserved: __u32,
    pub raw: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_fscrypt_provisioning_key_payload() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_provisioning_key_payload>(),
        8usize,
        concat!("Size of: ", stringify!(fscrypt_provisioning_key_payload))
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_provisioning_key_payload>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(fscrypt_provisioning_key_payload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_provisioning_key_payload>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_provisioning_key_payload),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_provisioning_key_payload>())).__reserved as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_provisioning_key_payload),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_provisioning_key_payload>())).raw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_provisioning_key_payload),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
pub struct fscrypt_add_key_arg {
    pub key_spec: fscrypt_key_specifier,
    pub raw_size: __u32,
    pub key_id: __u32,
    pub __reserved: [__u32; 8usize],
    pub raw: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_fscrypt_add_key_arg() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_add_key_arg>(),
        80usize,
        concat!("Size of: ", stringify!(fscrypt_add_key_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_add_key_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(fscrypt_add_key_arg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_add_key_arg>())).key_spec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_add_key_arg),
            "::",
            stringify!(key_spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_add_key_arg>())).raw_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_add_key_arg),
            "::",
            stringify!(raw_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_add_key_arg>())).key_id as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_add_key_arg),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_add_key_arg>())).__reserved as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_add_key_arg),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_add_key_arg>())).raw as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_add_key_arg),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_remove_key_arg {
    pub key_spec: fscrypt_key_specifier,
    pub removal_status_flags: __u32,
    pub __reserved: [__u32; 5usize],
}
#[test]
fn bindgen_test_layout_fscrypt_remove_key_arg() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_remove_key_arg>(),
        64usize,
        concat!("Size of: ", stringify!(fscrypt_remove_key_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_remove_key_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(fscrypt_remove_key_arg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fscrypt_remove_key_arg>())).key_spec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_remove_key_arg),
            "::",
            stringify!(key_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_remove_key_arg>())).removal_status_flags as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_remove_key_arg),
            "::",
            stringify!(removal_status_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_remove_key_arg>())).__reserved as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_remove_key_arg),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_get_key_status_arg {
    pub key_spec: fscrypt_key_specifier,
    pub __reserved: [__u32; 6usize],
    pub status: __u32,
    pub status_flags: __u32,
    pub user_count: __u32,
    pub __out_reserved: [__u32; 13usize],
}
#[test]
fn bindgen_test_layout_fscrypt_get_key_status_arg() {
    assert_eq!(
        ::std::mem::size_of::<fscrypt_get_key_status_arg>(),
        128usize,
        concat!("Size of: ", stringify!(fscrypt_get_key_status_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<fscrypt_get_key_status_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(fscrypt_get_key_status_arg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_key_status_arg>())).key_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_key_status_arg),
            "::",
            stringify!(key_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_key_status_arg>())).__reserved as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_key_status_arg),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_key_status_arg>())).status as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_key_status_arg),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_key_status_arg>())).status_flags as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_key_status_arg),
            "::",
            stringify!(status_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_key_status_arg>())).user_count as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_key_status_arg),
            "::",
            stringify!(user_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fscrypt_get_key_status_arg>())).__out_reserved as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(fscrypt_get_key_status_arg),
            "::",
            stringify!(__out_reserved)
        )
    );
}
pub const fsconfig_command_FSCONFIG_SET_FLAG: fsconfig_command = 0;
pub const fsconfig_command_FSCONFIG_SET_STRING: fsconfig_command = 1;
pub const fsconfig_command_FSCONFIG_SET_BINARY: fsconfig_command = 2;
pub const fsconfig_command_FSCONFIG_SET_PATH: fsconfig_command = 3;
pub const fsconfig_command_FSCONFIG_SET_PATH_EMPTY: fsconfig_command = 4;
pub const fsconfig_command_FSCONFIG_SET_FD: fsconfig_command = 5;
pub const fsconfig_command_FSCONFIG_CMD_CREATE: fsconfig_command = 6;
pub const fsconfig_command_FSCONFIG_CMD_RECONFIGURE: fsconfig_command = 7;
pub type fsconfig_command = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount_attr {
    pub attr_set: __u64,
    pub attr_clr: __u64,
    pub propagation: __u64,
    pub userns_fd: __u64,
}
#[test]
fn bindgen_test_layout_mount_attr() {
    assert_eq!(
        ::std::mem::size_of::<mount_attr>(),
        32usize,
        concat!("Size of: ", stringify!(mount_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<mount_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(mount_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mount_attr>())).attr_set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mount_attr),
            "::",
            stringify!(attr_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mount_attr>())).attr_clr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mount_attr),
            "::",
            stringify!(attr_clr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mount_attr>())).propagation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mount_attr),
            "::",
            stringify!(propagation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mount_attr>())).userns_fd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mount_attr),
            "::",
            stringify!(userns_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_clone_range {
    pub src_fd: __s64,
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_offset: __u64,
}
#[test]
fn bindgen_test_layout_file_clone_range() {
    assert_eq!(
        ::std::mem::size_of::<file_clone_range>(),
        32usize,
        concat!("Size of: ", stringify!(file_clone_range))
    );
    assert_eq!(
        ::std::mem::align_of::<file_clone_range>(),
        8usize,
        concat!("Alignment of ", stringify!(file_clone_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_clone_range>())).src_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_clone_range),
            "::",
            stringify!(src_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_clone_range>())).src_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_clone_range),
            "::",
            stringify!(src_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_clone_range>())).src_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_clone_range),
            "::",
            stringify!(src_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_clone_range>())).dest_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_clone_range),
            "::",
            stringify!(dest_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fstrim_range {
    pub start: __u64,
    pub len: __u64,
    pub minlen: __u64,
}
#[test]
fn bindgen_test_layout_fstrim_range() {
    assert_eq!(
        ::std::mem::size_of::<fstrim_range>(),
        24usize,
        concat!("Size of: ", stringify!(fstrim_range))
    );
    assert_eq!(
        ::std::mem::align_of::<fstrim_range>(),
        8usize,
        concat!("Alignment of ", stringify!(fstrim_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstrim_range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fstrim_range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstrim_range>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fstrim_range),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstrim_range>())).minlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fstrim_range),
            "::",
            stringify!(minlen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_dedupe_range_info {
    pub dest_fd: __s64,
    pub dest_offset: __u64,
    pub bytes_deduped: __u64,
    pub status: __s32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_file_dedupe_range_info() {
    assert_eq!(
        ::std::mem::size_of::<file_dedupe_range_info>(),
        32usize,
        concat!("Size of: ", stringify!(file_dedupe_range_info))
    );
    assert_eq!(
        ::std::mem::align_of::<file_dedupe_range_info>(),
        8usize,
        concat!("Alignment of ", stringify!(file_dedupe_range_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range_info>())).dest_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range_info),
            "::",
            stringify!(dest_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_dedupe_range_info>())).dest_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range_info),
            "::",
            stringify!(dest_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_dedupe_range_info>())).bytes_deduped as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range_info),
            "::",
            stringify!(bytes_deduped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range_info>())).status as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range_info),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range_info>())).reserved as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range_info),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct file_dedupe_range {
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_count: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
    pub info: __IncompleteArrayField<file_dedupe_range_info>,
}
#[test]
fn bindgen_test_layout_file_dedupe_range() {
    assert_eq!(
        ::std::mem::size_of::<file_dedupe_range>(),
        24usize,
        concat!("Size of: ", stringify!(file_dedupe_range))
    );
    assert_eq!(
        ::std::mem::align_of::<file_dedupe_range>(),
        8usize,
        concat!("Alignment of ", stringify!(file_dedupe_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).src_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(src_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).src_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(src_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).dest_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(dest_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).reserved1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).reserved2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct files_stat_struct {
    pub nr_files: ::std::os::raw::c_ulong,
    pub nr_free_files: ::std::os::raw::c_ulong,
    pub max_files: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_files_stat_struct() {
    assert_eq!(
        ::std::mem::size_of::<files_stat_struct>(),
        24usize,
        concat!("Size of: ", stringify!(files_stat_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<files_stat_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(files_stat_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<files_stat_struct>())).nr_files as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(files_stat_struct),
            "::",
            stringify!(nr_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<files_stat_struct>())).nr_free_files as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(files_stat_struct),
            "::",
            stringify!(nr_free_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<files_stat_struct>())).max_files as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(files_stat_struct),
            "::",
            stringify!(max_files)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inodes_stat_t {
    pub nr_inodes: ::std::os::raw::c_long,
    pub nr_unused: ::std::os::raw::c_long,
    pub dummy: [::std::os::raw::c_long; 5usize],
}
#[test]
fn bindgen_test_layout_inodes_stat_t() {
    assert_eq!(
        ::std::mem::size_of::<inodes_stat_t>(),
        56usize,
        concat!("Size of: ", stringify!(inodes_stat_t))
    );
    assert_eq!(
        ::std::mem::align_of::<inodes_stat_t>(),
        8usize,
        concat!("Alignment of ", stringify!(inodes_stat_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inodes_stat_t>())).nr_inodes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inodes_stat_t),
            "::",
            stringify!(nr_inodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inodes_stat_t>())).nr_unused as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inodes_stat_t),
            "::",
            stringify!(nr_unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inodes_stat_t>())).dummy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inodes_stat_t),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsxattr {
    pub fsx_xflags: __u32,
    pub fsx_extsize: __u32,
    pub fsx_nextents: __u32,
    pub fsx_projid: __u32,
    pub fsx_cowextsize: __u32,
    pub fsx_pad: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_fsxattr() {
    assert_eq!(
        ::std::mem::size_of::<fsxattr>(),
        28usize,
        concat!("Size of: ", stringify!(fsxattr))
    );
    assert_eq!(
        ::std::mem::align_of::<fsxattr>(),
        4usize,
        concat!("Alignment of ", stringify!(fsxattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_xflags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_xflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_extsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_extsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_nextents as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_nextents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_projid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_projid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_cowextsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_cowextsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_pad as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_pad)
        )
    );
}
pub type __kernel_rwf_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_vol_args {
    pub fd: __s64,
    pub name: [::std::os::raw::c_char; 4088usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_vol_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_vol_args>(),
        4096usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_vol_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_vol_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_vol_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_vol_args>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_vol_args>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_qgroup_limit {
    pub flags: __u64,
    pub max_rfer: __u64,
    pub max_excl: __u64,
    pub rsv_rfer: __u64,
    pub rsv_excl: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_qgroup_limit() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_qgroup_limit>(),
        40usize,
        concat!("Size of: ", stringify!(btrfs_qgroup_limit))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_qgroup_limit>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_qgroup_limit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_qgroup_limit>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_limit),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_qgroup_limit>())).max_rfer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_limit),
            "::",
            stringify!(max_rfer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_qgroup_limit>())).max_excl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_limit),
            "::",
            stringify!(max_excl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_qgroup_limit>())).rsv_rfer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_limit),
            "::",
            stringify!(rsv_rfer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_qgroup_limit>())).rsv_excl as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_limit),
            "::",
            stringify!(rsv_excl)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btrfs_qgroup_inherit {
    pub flags: __u64,
    pub num_qgroups: __u64,
    pub num_ref_copies: __u64,
    pub num_excl_copies: __u64,
    pub lim: btrfs_qgroup_limit,
    pub qgroups: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_btrfs_qgroup_inherit() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_qgroup_inherit>(),
        72usize,
        concat!("Size of: ", stringify!(btrfs_qgroup_inherit))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_qgroup_inherit>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_qgroup_inherit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_qgroup_inherit>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_inherit),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_qgroup_inherit>())).num_qgroups as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_inherit),
            "::",
            stringify!(num_qgroups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_qgroup_inherit>())).num_ref_copies as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_inherit),
            "::",
            stringify!(num_ref_copies)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_qgroup_inherit>())).num_excl_copies as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_inherit),
            "::",
            stringify!(num_excl_copies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_qgroup_inherit>())).lim as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_inherit),
            "::",
            stringify!(lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_qgroup_inherit>())).qgroups as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_qgroup_inherit),
            "::",
            stringify!(qgroups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_qgroup_limit_args {
    pub qgroupid: __u64,
    pub lim: btrfs_qgroup_limit,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_qgroup_limit_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_qgroup_limit_args>(),
        48usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_qgroup_limit_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_qgroup_limit_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_qgroup_limit_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_qgroup_limit_args>())).qgroupid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_qgroup_limit_args),
            "::",
            stringify!(qgroupid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_qgroup_limit_args>())).lim as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_qgroup_limit_args),
            "::",
            stringify!(lim)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_vol_args_v2 {
    pub fd: __s64,
    pub transid: __u64,
    pub flags: __u64,
    pub __bindgen_anon_1: btrfs_ioctl_vol_args_v2__bindgen_ty_1,
    pub __bindgen_anon_2: btrfs_ioctl_vol_args_v2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btrfs_ioctl_vol_args_v2__bindgen_ty_1 {
    pub __bindgen_anon_1: btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1,
    pub unused: [__u64; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1 {
    pub size: __u64,
    pub qgroup_inherit: *mut btrfs_qgroup_inherit,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1>())).size
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1>()))
                .qgroup_inherit as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(qgroup_inherit)
        )
    );
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_vol_args_v2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_vol_args_v2__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_vol_args_v2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_vol_args_v2__bindgen_ty_1>())).unused as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_1),
            "::",
            stringify!(unused)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btrfs_ioctl_vol_args_v2__bindgen_ty_2 {
    pub name: [::std::os::raw::c_char; 4040usize],
    pub devid: __u64,
    pub subvolid: __u64,
    _bindgen_union_align: [u64; 505usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_vol_args_v2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_vol_args_v2__bindgen_ty_2>(),
        4040usize,
        concat!(
            "Size of: ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_vol_args_v2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_vol_args_v2__bindgen_ty_2>())).name as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_2),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_vol_args_v2__bindgen_ty_2>())).devid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_2),
            "::",
            stringify!(devid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_vol_args_v2__bindgen_ty_2>())).subvolid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args_v2__bindgen_ty_2),
            "::",
            stringify!(subvolid)
        )
    );
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_vol_args_v2() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_vol_args_v2>(),
        4096usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_vol_args_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_vol_args_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_vol_args_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_vol_args_v2>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args_v2),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_vol_args_v2>())).transid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args_v2),
            "::",
            stringify!(transid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_vol_args_v2>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_vol_args_v2),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_scrub_progress {
    pub data_extents_scrubbed: __u64,
    pub tree_extents_scrubbed: __u64,
    pub data_bytes_scrubbed: __u64,
    pub tree_bytes_scrubbed: __u64,
    pub read_errors: __u64,
    pub csum_errors: __u64,
    pub verify_errors: __u64,
    pub no_csum: __u64,
    pub csum_discards: __u64,
    pub super_errors: __u64,
    pub malloc_errors: __u64,
    pub uncorrectable_errors: __u64,
    pub corrected_errors: __u64,
    pub last_physical: __u64,
    pub unverified_errors: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_scrub_progress() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_scrub_progress>(),
        120usize,
        concat!("Size of: ", stringify!(btrfs_scrub_progress))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_scrub_progress>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_scrub_progress))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).data_extents_scrubbed as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(data_extents_scrubbed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).tree_extents_scrubbed as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(tree_extents_scrubbed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).data_bytes_scrubbed as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(data_bytes_scrubbed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).tree_bytes_scrubbed as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(tree_bytes_scrubbed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).read_errors as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(read_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).csum_errors as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(csum_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).verify_errors as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(verify_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_scrub_progress>())).no_csum as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(no_csum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).csum_discards as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(csum_discards)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).super_errors as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(super_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).malloc_errors as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(malloc_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).uncorrectable_errors as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(uncorrectable_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).corrected_errors as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(corrected_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).last_physical as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(last_physical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_scrub_progress>())).unverified_errors as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_scrub_progress),
            "::",
            stringify!(unverified_errors)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_scrub_args {
    pub devid: __u64,
    pub start: __u64,
    pub end: __u64,
    pub flags: __u64,
    pub progress: btrfs_scrub_progress,
    pub unused: [__u64; 109usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_scrub_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_scrub_args>(),
        1024usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_scrub_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_scrub_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_scrub_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_scrub_args>())).devid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_scrub_args),
            "::",
            stringify!(devid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_scrub_args>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_scrub_args),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_scrub_args>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_scrub_args),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_scrub_args>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_scrub_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_scrub_args>())).progress as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_scrub_args),
            "::",
            stringify!(progress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_scrub_args>())).unused as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_scrub_args),
            "::",
            stringify!(unused)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_dev_replace_start_params {
    pub srcdevid: __u64,
    pub cont_reading_from_srcdev_mode: __u64,
    pub srcdev_name: [__u8; 1025usize],
    pub tgtdev_name: [__u8; 1025usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_dev_replace_start_params() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_dev_replace_start_params>(),
        2072usize,
        concat!(
            "Size of: ",
            stringify!(btrfs_ioctl_dev_replace_start_params)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_dev_replace_start_params>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_dev_replace_start_params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_start_params>())).srcdevid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_start_params),
            "::",
            stringify!(srcdevid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_start_params>()))
                .cont_reading_from_srcdev_mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_start_params),
            "::",
            stringify!(cont_reading_from_srcdev_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_start_params>())).srcdev_name as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_start_params),
            "::",
            stringify!(srcdev_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_start_params>())).tgtdev_name as *const _
                as usize
        },
        1041usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_start_params),
            "::",
            stringify!(tgtdev_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_dev_replace_status_params {
    pub replace_state: __u64,
    pub progress_1000: __u64,
    pub time_started: __u64,
    pub time_stopped: __u64,
    pub num_write_errors: __u64,
    pub num_uncorrectable_read_errors: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_dev_replace_status_params() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_dev_replace_status_params>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(btrfs_ioctl_dev_replace_status_params)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_dev_replace_status_params>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_dev_replace_status_params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_status_params>())).replace_state
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_status_params),
            "::",
            stringify!(replace_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_status_params>())).progress_1000
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_status_params),
            "::",
            stringify!(progress_1000)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_status_params>())).time_started
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_status_params),
            "::",
            stringify!(time_started)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_status_params>())).time_stopped
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_status_params),
            "::",
            stringify!(time_stopped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_status_params>())).num_write_errors
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_status_params),
            "::",
            stringify!(num_write_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_status_params>()))
                .num_uncorrectable_read_errors as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_status_params),
            "::",
            stringify!(num_uncorrectable_read_errors)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_dev_replace_args {
    pub cmd: __u64,
    pub result: __u64,
    pub __bindgen_anon_1: btrfs_ioctl_dev_replace_args__bindgen_ty_1,
    pub spare: [__u64; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btrfs_ioctl_dev_replace_args__bindgen_ty_1 {
    pub start: btrfs_ioctl_dev_replace_start_params,
    pub status: btrfs_ioctl_dev_replace_status_params,
    _bindgen_union_align: [u64; 259usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_dev_replace_args__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_dev_replace_args__bindgen_ty_1>(),
        2072usize,
        concat!(
            "Size of: ",
            stringify!(btrfs_ioctl_dev_replace_args__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_dev_replace_args__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_dev_replace_args__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_args__bindgen_ty_1>())).start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_args__bindgen_ty_1),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_args__bindgen_ty_1>())).status
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_args__bindgen_ty_1),
            "::",
            stringify!(status)
        )
    );
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_dev_replace_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_dev_replace_args>(),
        2600usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_dev_replace_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_dev_replace_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_dev_replace_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_args>())).cmd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_args),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_args>())).result as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_args),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_replace_args>())).spare as *const _ as usize
        },
        2088usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_replace_args),
            "::",
            stringify!(spare)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_dev_info_args {
    pub devid: __u64,
    pub uuid: [__u8; 16usize],
    pub bytes_used: __u64,
    pub total_bytes: __u64,
    pub unused: [__u64; 379usize],
    pub path: [__u8; 1024usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_dev_info_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_dev_info_args>(),
        4096usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_dev_info_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_dev_info_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_dev_info_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_dev_info_args>())).devid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_info_args),
            "::",
            stringify!(devid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_dev_info_args>())).uuid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_info_args),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_info_args>())).bytes_used as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_info_args),
            "::",
            stringify!(bytes_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_info_args>())).total_bytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_info_args),
            "::",
            stringify!(total_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_dev_info_args>())).unused as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_info_args),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_dev_info_args>())).path as *const _ as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_dev_info_args),
            "::",
            stringify!(path)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_fs_info_args {
    pub max_id: __u64,
    pub num_devices: __u64,
    pub fsid: [__u8; 16usize],
    pub nodesize: __u32,
    pub sectorsize: __u32,
    pub clone_alignment: __u32,
    pub csum_type: __u16,
    pub csum_size: __u16,
    pub flags: __u64,
    pub generation: __u64,
    pub metadata_uuid: [__u8; 16usize],
    pub reserved: [__u8; 944usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_fs_info_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_fs_info_args>(),
        1024usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_fs_info_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_fs_info_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_fs_info_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).max_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(max_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).num_devices as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(num_devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).fsid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(fsid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).nodesize as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(nodesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).sectorsize as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(sectorsize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).clone_alignment as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(clone_alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).csum_type as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(csum_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).csum_size as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(csum_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).generation as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(generation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).metadata_uuid as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(metadata_uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_fs_info_args>())).reserved as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_fs_info_args),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_feature_flags {
    pub compat_flags: __u64,
    pub compat_ro_flags: __u64,
    pub incompat_flags: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_feature_flags() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_feature_flags>(),
        24usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_feature_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_feature_flags>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_feature_flags))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_feature_flags>())).compat_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_feature_flags),
            "::",
            stringify!(compat_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_feature_flags>())).compat_ro_flags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_feature_flags),
            "::",
            stringify!(compat_ro_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_feature_flags>())).incompat_flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_feature_flags),
            "::",
            stringify!(incompat_flags)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct btrfs_balance_args {
    pub profiles: __u64,
    pub __bindgen_anon_1: btrfs_balance_args__bindgen_ty_1,
    pub devid: __u64,
    pub pstart: __u64,
    pub pend: __u64,
    pub vstart: __u64,
    pub vend: __u64,
    pub target: __u64,
    pub flags: __u64,
    pub __bindgen_anon_2: btrfs_balance_args__bindgen_ty_2,
    pub stripes_min: __u32,
    pub stripes_max: __u32,
    pub unused: [__u64; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btrfs_balance_args__bindgen_ty_1 {
    pub usage: __u64,
    pub __bindgen_anon_1: btrfs_balance_args__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_balance_args__bindgen_ty_1__bindgen_ty_1 {
    pub usage_min: __u32,
    pub usage_max: __u32,
}
#[test]
fn bindgen_test_layout_btrfs_balance_args__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_balance_args__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(btrfs_balance_args__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_balance_args__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_balance_args__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_balance_args__bindgen_ty_1__bindgen_ty_1>())).usage_min
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(usage_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_balance_args__bindgen_ty_1__bindgen_ty_1>())).usage_max
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(usage_max)
        )
    );
}
#[test]
fn bindgen_test_layout_btrfs_balance_args__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_balance_args__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(btrfs_balance_args__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_balance_args__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_balance_args__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_balance_args__bindgen_ty_1>())).usage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args__bindgen_ty_1),
            "::",
            stringify!(usage)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btrfs_balance_args__bindgen_ty_2 {
    pub limit: __u64,
    pub __bindgen_anon_1: btrfs_balance_args__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_balance_args__bindgen_ty_2__bindgen_ty_1 {
    pub limit_min: __u32,
    pub limit_max: __u32,
}
#[test]
fn bindgen_test_layout_btrfs_balance_args__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_balance_args__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(btrfs_balance_args__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_balance_args__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_balance_args__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_balance_args__bindgen_ty_2__bindgen_ty_1>())).limit_min
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(limit_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_balance_args__bindgen_ty_2__bindgen_ty_1>())).limit_max
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(limit_max)
        )
    );
}
#[test]
fn bindgen_test_layout_btrfs_balance_args__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_balance_args__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(btrfs_balance_args__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_balance_args__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_balance_args__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_balance_args__bindgen_ty_2>())).limit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args__bindgen_ty_2),
            "::",
            stringify!(limit)
        )
    );
}
#[test]
fn bindgen_test_layout_btrfs_balance_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_balance_args>(),
        136usize,
        concat!("Size of: ", stringify!(btrfs_balance_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_balance_args>(),
        1usize,
        concat!("Alignment of ", stringify!(btrfs_balance_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).profiles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(profiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).devid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(devid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).pstart as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(pstart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).pend as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(pend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).vstart as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(vstart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).vend as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(vend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).target as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).stripes_min as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(stripes_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).stripes_max as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(stripes_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_args>())).unused as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_args),
            "::",
            stringify!(unused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_balance_progress {
    pub expected: __u64,
    pub considered: __u64,
    pub completed: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_balance_progress() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_balance_progress>(),
        24usize,
        concat!("Size of: ", stringify!(btrfs_balance_progress))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_balance_progress>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_balance_progress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_balance_progress>())).expected as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_progress),
            "::",
            stringify!(expected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_balance_progress>())).considered as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_progress),
            "::",
            stringify!(considered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_balance_progress>())).completed as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_balance_progress),
            "::",
            stringify!(completed)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_balance_args {
    pub flags: __u64,
    pub state: __u64,
    pub data: btrfs_balance_args,
    pub meta: btrfs_balance_args,
    pub sys: btrfs_balance_args,
    pub stat: btrfs_balance_progress,
    pub unused: [__u64; 72usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_balance_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_balance_args>(),
        1024usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_balance_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_balance_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_balance_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_balance_args>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_balance_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_balance_args>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_balance_args),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_balance_args>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_balance_args),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_balance_args>())).meta as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_balance_args),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_balance_args>())).sys as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_balance_args),
            "::",
            stringify!(sys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_balance_args>())).stat as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_balance_args),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_balance_args>())).unused as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_balance_args),
            "::",
            stringify!(unused)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_ino_lookup_args {
    pub treeid: __u64,
    pub objectid: __u64,
    pub name: [::std::os::raw::c_char; 4080usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_ino_lookup_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_ino_lookup_args>(),
        4096usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_ino_lookup_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_ino_lookup_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_ino_lookup_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_ino_lookup_args>())).treeid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_lookup_args),
            "::",
            stringify!(treeid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_ino_lookup_args>())).objectid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_lookup_args),
            "::",
            stringify!(objectid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_ino_lookup_args>())).name as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_lookup_args),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_ino_lookup_user_args {
    pub dirid: __u64,
    pub treeid: __u64,
    pub name: [::std::os::raw::c_char; 256usize],
    pub path: [::std::os::raw::c_char; 3824usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_ino_lookup_user_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_ino_lookup_user_args>(),
        4096usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_ino_lookup_user_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_ino_lookup_user_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_ino_lookup_user_args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_ino_lookup_user_args>())).dirid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_lookup_user_args),
            "::",
            stringify!(dirid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_ino_lookup_user_args>())).treeid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_lookup_user_args),
            "::",
            stringify!(treeid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_ino_lookup_user_args>())).name as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_lookup_user_args),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_ino_lookup_user_args>())).path as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_lookup_user_args),
            "::",
            stringify!(path)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_search_key {
    pub tree_id: __u64,
    pub min_objectid: __u64,
    pub max_objectid: __u64,
    pub min_offset: __u64,
    pub max_offset: __u64,
    pub min_transid: __u64,
    pub max_transid: __u64,
    pub min_type: __u32,
    pub max_type: __u32,
    pub nr_items: __u32,
    pub unused: __u32,
    pub unused1: __u64,
    pub unused2: __u64,
    pub unused3: __u64,
    pub unused4: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_search_key() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_search_key>(),
        104usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_search_key))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_search_key>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_search_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).tree_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(tree_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).min_objectid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(min_objectid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).max_objectid as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(max_objectid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).min_offset as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(min_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).max_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(max_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).min_transid as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(min_transid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).max_transid as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(max_transid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).min_type as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(min_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).max_type as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(max_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).nr_items as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(nr_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).unused as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).unused1 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).unused2 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(unused2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).unused3 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(unused3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_key>())).unused4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_key),
            "::",
            stringify!(unused4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_search_header {
    pub transid: __u64,
    pub objectid: __u64,
    pub offset: __u64,
    pub type_: __u32,
    pub len: __u32,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_search_header() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_search_header>(),
        32usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_search_header))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_search_header>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_search_header))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_search_header>())).transid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_header),
            "::",
            stringify!(transid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_search_header>())).objectid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_header),
            "::",
            stringify!(objectid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_search_header>())).offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_header),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_header>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_header),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_header>())).len as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_header),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_search_args {
    pub key: btrfs_ioctl_search_key,
    pub buf: [::std::os::raw::c_char; 3992usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_search_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_search_args>(),
        4096usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_search_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_search_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_search_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_args>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_args),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_args>())).buf as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_args),
            "::",
            stringify!(buf)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btrfs_ioctl_search_args_v2 {
    pub key: btrfs_ioctl_search_key,
    pub buf_size: __u64,
    pub buf: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_search_args_v2() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_search_args_v2>(),
        112usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_search_args_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_search_args_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_search_args_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_args_v2>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_args_v2),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_search_args_v2>())).buf_size as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_args_v2),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_search_args_v2>())).buf as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_search_args_v2),
            "::",
            stringify!(buf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_clone_range_args {
    pub src_fd: __s64,
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_offset: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_clone_range_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_clone_range_args>(),
        32usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_clone_range_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_clone_range_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_clone_range_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_clone_range_args>())).src_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_clone_range_args),
            "::",
            stringify!(src_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_clone_range_args>())).src_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_clone_range_args),
            "::",
            stringify!(src_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_clone_range_args>())).src_length as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_clone_range_args),
            "::",
            stringify!(src_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_clone_range_args>())).dest_offset as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_clone_range_args),
            "::",
            stringify!(dest_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_defrag_range_args {
    pub start: __u64,
    pub len: __u64,
    pub flags: __u64,
    pub extent_thresh: __u32,
    pub compress_type: __u32,
    pub unused: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_defrag_range_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_defrag_range_args>(),
        48usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_defrag_range_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_defrag_range_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_defrag_range_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_defrag_range_args>())).start as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_defrag_range_args),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_defrag_range_args>())).len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_defrag_range_args),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_defrag_range_args>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_defrag_range_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_defrag_range_args>())).extent_thresh as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_defrag_range_args),
            "::",
            stringify!(extent_thresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_defrag_range_args>())).compress_type as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_defrag_range_args),
            "::",
            stringify!(compress_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_defrag_range_args>())).unused as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_defrag_range_args),
            "::",
            stringify!(unused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_same_extent_info {
    pub fd: __s64,
    pub logical_offset: __u64,
    pub bytes_deduped: __u64,
    pub status: __s32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_same_extent_info() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_same_extent_info>(),
        32usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_same_extent_info))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_same_extent_info>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_same_extent_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_same_extent_info>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_extent_info),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_same_extent_info>())).logical_offset as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_extent_info),
            "::",
            stringify!(logical_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_same_extent_info>())).bytes_deduped as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_extent_info),
            "::",
            stringify!(bytes_deduped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_same_extent_info>())).status as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_extent_info),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_same_extent_info>())).reserved as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_extent_info),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btrfs_ioctl_same_args {
    pub logical_offset: __u64,
    pub length: __u64,
    pub dest_count: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
    pub info: __IncompleteArrayField<btrfs_ioctl_same_extent_info>,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_same_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_same_args>(),
        24usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_same_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_same_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_same_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_same_args>())).logical_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_args),
            "::",
            stringify!(logical_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_same_args>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_args),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_same_args>())).dest_count as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_args),
            "::",
            stringify!(dest_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_same_args>())).reserved1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_args),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_same_args>())).reserved2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_args),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_same_args>())).info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_same_args),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_space_info {
    pub flags: __u64,
    pub total_bytes: __u64,
    pub used_bytes: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_space_info() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_space_info>(),
        24usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_space_info))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_space_info>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_space_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_space_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_space_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_space_info>())).total_bytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_space_info),
            "::",
            stringify!(total_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_space_info>())).used_bytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_space_info),
            "::",
            stringify!(used_bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btrfs_ioctl_space_args {
    pub space_slots: __u64,
    pub total_spaces: __u64,
    pub spaces: __IncompleteArrayField<btrfs_ioctl_space_info>,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_space_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_space_args>(),
        16usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_space_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_space_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_space_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_space_args>())).space_slots as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_space_args),
            "::",
            stringify!(space_slots)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_space_args>())).total_spaces as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_space_args),
            "::",
            stringify!(total_spaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_space_args>())).spaces as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_space_args),
            "::",
            stringify!(spaces)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btrfs_data_container {
    pub bytes_left: __u32,
    pub bytes_missing: __u32,
    pub elem_cnt: __u32,
    pub elem_missed: __u32,
    pub val: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_btrfs_data_container() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_data_container>(),
        16usize,
        concat!("Size of: ", stringify!(btrfs_data_container))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_data_container>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_data_container))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_data_container>())).bytes_left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_data_container),
            "::",
            stringify!(bytes_left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_data_container>())).bytes_missing as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_data_container),
            "::",
            stringify!(bytes_missing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_data_container>())).elem_cnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_data_container),
            "::",
            stringify!(elem_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_data_container>())).elem_missed as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_data_container),
            "::",
            stringify!(elem_missed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_data_container>())).val as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_data_container),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_ino_path_args {
    pub inum: __u64,
    pub size: __u64,
    pub reserved: [__u64; 4usize],
    pub fspath: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_ino_path_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_ino_path_args>(),
        56usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_ino_path_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_ino_path_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_ino_path_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_ino_path_args>())).inum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_path_args),
            "::",
            stringify!(inum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_ino_path_args>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_path_args),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_ino_path_args>())).reserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_path_args),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_ino_path_args>())).fspath as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_ino_path_args),
            "::",
            stringify!(fspath)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_logical_ino_args {
    pub logical: __u64,
    pub size: __u64,
    pub reserved: [__u64; 3usize],
    pub flags: __u64,
    pub inodes: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_logical_ino_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_logical_ino_args>(),
        56usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_logical_ino_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_logical_ino_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_logical_ino_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_logical_ino_args>())).logical as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_logical_ino_args),
            "::",
            stringify!(logical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_logical_ino_args>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_logical_ino_args),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_logical_ino_args>())).reserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_logical_ino_args),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_logical_ino_args>())).flags as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_logical_ino_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_logical_ino_args>())).inodes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_logical_ino_args),
            "::",
            stringify!(inodes)
        )
    );
}
pub const btrfs_dev_stat_values_BTRFS_DEV_STAT_WRITE_ERRS: btrfs_dev_stat_values = 0;
pub const btrfs_dev_stat_values_BTRFS_DEV_STAT_READ_ERRS: btrfs_dev_stat_values = 1;
pub const btrfs_dev_stat_values_BTRFS_DEV_STAT_FLUSH_ERRS: btrfs_dev_stat_values = 2;
pub const btrfs_dev_stat_values_BTRFS_DEV_STAT_CORRUPTION_ERRS: btrfs_dev_stat_values = 3;
pub const btrfs_dev_stat_values_BTRFS_DEV_STAT_GENERATION_ERRS: btrfs_dev_stat_values = 4;
pub const btrfs_dev_stat_values_BTRFS_DEV_STAT_VALUES_MAX: btrfs_dev_stat_values = 5;
pub type btrfs_dev_stat_values = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_get_dev_stats {
    pub devid: __u64,
    pub nr_items: __u64,
    pub flags: __u64,
    pub values: [__u64; 5usize],
    pub unused: [__u64; 121usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_get_dev_stats() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_get_dev_stats>(),
        1032usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_get_dev_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_get_dev_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_get_dev_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_get_dev_stats>())).devid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_dev_stats),
            "::",
            stringify!(devid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_dev_stats>())).nr_items as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_dev_stats),
            "::",
            stringify!(nr_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_get_dev_stats>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_dev_stats),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_dev_stats>())).values as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_dev_stats),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_dev_stats>())).unused as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_dev_stats),
            "::",
            stringify!(unused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_quota_ctl_args {
    pub cmd: __u64,
    pub status: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_quota_ctl_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_quota_ctl_args>(),
        16usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_quota_ctl_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_quota_ctl_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_quota_ctl_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_quota_ctl_args>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_quota_ctl_args),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_quota_ctl_args>())).status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_quota_ctl_args),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_quota_rescan_args {
    pub flags: __u64,
    pub progress: __u64,
    pub reserved: [__u64; 6usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_quota_rescan_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_quota_rescan_args>(),
        64usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_quota_rescan_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_quota_rescan_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_quota_rescan_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_quota_rescan_args>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_quota_rescan_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_quota_rescan_args>())).progress as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_quota_rescan_args),
            "::",
            stringify!(progress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_quota_rescan_args>())).reserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_quota_rescan_args),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_qgroup_assign_args {
    pub assign: __u64,
    pub src: __u64,
    pub dst: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_qgroup_assign_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_qgroup_assign_args>(),
        24usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_qgroup_assign_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_qgroup_assign_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_qgroup_assign_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_qgroup_assign_args>())).assign as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_qgroup_assign_args),
            "::",
            stringify!(assign)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_qgroup_assign_args>())).src as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_qgroup_assign_args),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_qgroup_assign_args>())).dst as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_qgroup_assign_args),
            "::",
            stringify!(dst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_qgroup_create_args {
    pub create: __u64,
    pub qgroupid: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_qgroup_create_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_qgroup_create_args>(),
        16usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_qgroup_create_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_qgroup_create_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_qgroup_create_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_qgroup_create_args>())).create as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_qgroup_create_args),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_qgroup_create_args>())).qgroupid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_qgroup_create_args),
            "::",
            stringify!(qgroupid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_timespec {
    pub sec: __u64,
    pub nsec: __u32,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_timespec() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_timespec>())).sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_timespec),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_timespec>())).nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_timespec),
            "::",
            stringify!(nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_received_subvol_args {
    pub uuid: [::std::os::raw::c_char; 16usize],
    pub stransid: __u64,
    pub rtransid: __u64,
    pub stime: btrfs_ioctl_timespec,
    pub rtime: btrfs_ioctl_timespec,
    pub flags: __u64,
    pub reserved: [__u64; 16usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_received_subvol_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_received_subvol_args>(),
        200usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_received_subvol_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_received_subvol_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_received_subvol_args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_received_subvol_args>())).uuid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_received_subvol_args),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_received_subvol_args>())).stransid as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_received_subvol_args),
            "::",
            stringify!(stransid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_received_subvol_args>())).rtransid as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_received_subvol_args),
            "::",
            stringify!(rtransid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_received_subvol_args>())).stime as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_received_subvol_args),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_received_subvol_args>())).rtime as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_received_subvol_args),
            "::",
            stringify!(rtime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_received_subvol_args>())).flags as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_received_subvol_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_received_subvol_args>())).reserved as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_received_subvol_args),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_send_args {
    pub send_fd: __s64,
    pub clone_sources_count: __u64,
    pub clone_sources: *mut __u64,
    pub parent_root: __u64,
    pub flags: __u64,
    pub version: __u32,
    pub reserved: [__u8; 28usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_send_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_send_args>(),
        72usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_send_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_send_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_send_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_send_args>())).send_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_send_args),
            "::",
            stringify!(send_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_send_args>())).clone_sources_count as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_send_args),
            "::",
            stringify!(clone_sources_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_send_args>())).clone_sources as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_send_args),
            "::",
            stringify!(clone_sources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_send_args>())).parent_root as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_send_args),
            "::",
            stringify!(parent_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_send_args>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_send_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_send_args>())).version as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_send_args),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_send_args>())).reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_send_args),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_get_subvol_info_args {
    pub treeid: __u64,
    pub name: [::std::os::raw::c_char; 256usize],
    pub parent_id: __u64,
    pub dirid: __u64,
    pub generation: __u64,
    pub flags: __u64,
    pub uuid: [__u8; 16usize],
    pub parent_uuid: [__u8; 16usize],
    pub received_uuid: [__u8; 16usize],
    pub ctransid: __u64,
    pub otransid: __u64,
    pub stransid: __u64,
    pub rtransid: __u64,
    pub ctime: btrfs_ioctl_timespec,
    pub otime: btrfs_ioctl_timespec,
    pub stime: btrfs_ioctl_timespec,
    pub rtime: btrfs_ioctl_timespec,
    pub reserved: [__u64; 8usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_get_subvol_info_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_get_subvol_info_args>(),
        504usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_get_subvol_info_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_get_subvol_info_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_get_subvol_info_args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).treeid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(treeid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).parent_id as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(parent_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).dirid as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(dirid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).generation as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(generation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).flags as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).uuid as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).parent_uuid as *const _
                as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(parent_uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).received_uuid as *const _
                as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(received_uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).ctransid as *const _
                as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(ctransid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).otransid as *const _
                as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(otransid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).stransid as *const _
                as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(stransid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).rtransid as *const _
                as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(rtransid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).ctime as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(ctime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).otime as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(otime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).stime as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).rtime as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(rtime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_info_args>())).reserved as *const _
                as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_info_args),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_get_subvol_rootref_args {
    pub min_treeid: __u64,
    pub rootref: [btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1; 255usize],
    pub num_items: __u8,
    pub align: [__u8; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1 {
    pub treeid: __u64,
    pub dirid: __u64,
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1>())).treeid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1),
            "::",
            stringify!(treeid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1>())).dirid
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_rootref_args__bindgen_ty_1),
            "::",
            stringify!(dirid)
        )
    );
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_get_subvol_rootref_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_get_subvol_rootref_args>(),
        4096usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_get_subvol_rootref_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_get_subvol_rootref_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btrfs_ioctl_get_subvol_rootref_args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_rootref_args>())).min_treeid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_rootref_args),
            "::",
            stringify!(min_treeid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_rootref_args>())).rootref as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_rootref_args),
            "::",
            stringify!(rootref)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_rootref_args>())).num_items as *const _
                as usize
        },
        4088usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_rootref_args),
            "::",
            stringify!(num_items)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_get_subvol_rootref_args>())).align as *const _
                as usize
        },
        4089usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_get_subvol_rootref_args),
            "::",
            stringify!(align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btrfs_ioctl_encoded_io_args {
    pub iov: *mut iovec,
    pub iovcnt: ::std::os::raw::c_ulong,
    pub offset: __s64,
    pub flags: __u64,
    pub len: __u64,
    pub unencoded_len: __u64,
    pub unencoded_offset: __u64,
    pub compression: __u32,
    pub encryption: __u32,
    pub reserved: [__u8; 64usize],
}
#[test]
fn bindgen_test_layout_btrfs_ioctl_encoded_io_args() {
    assert_eq!(
        ::std::mem::size_of::<btrfs_ioctl_encoded_io_args>(),
        128usize,
        concat!("Size of: ", stringify!(btrfs_ioctl_encoded_io_args))
    );
    assert_eq!(
        ::std::mem::align_of::<btrfs_ioctl_encoded_io_args>(),
        8usize,
        concat!("Alignment of ", stringify!(btrfs_ioctl_encoded_io_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_encoded_io_args>())).iov as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_encoded_io_args),
            "::",
            stringify!(iov)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_encoded_io_args>())).iovcnt as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_encoded_io_args),
            "::",
            stringify!(iovcnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_encoded_io_args>())).offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_encoded_io_args),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_encoded_io_args>())).flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_encoded_io_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<btrfs_ioctl_encoded_io_args>())).len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_encoded_io_args),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_encoded_io_args>())).unencoded_len as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_encoded_io_args),
            "::",
            stringify!(unencoded_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_encoded_io_args>())).unencoded_offset as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_encoded_io_args),
            "::",
            stringify!(unencoded_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_encoded_io_args>())).compression as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_encoded_io_args),
            "::",
            stringify!(compression)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_encoded_io_args>())).encryption as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_encoded_io_args),
            "::",
            stringify!(encryption)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<btrfs_ioctl_encoded_io_args>())).reserved as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(btrfs_ioctl_encoded_io_args),
            "::",
            stringify!(reserved)
        )
    );
}
pub const btrfs_err_code_BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET: btrfs_err_code = 1;
pub const btrfs_err_code_BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET: btrfs_err_code = 2;
pub const btrfs_err_code_BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET: btrfs_err_code = 3;
pub const btrfs_err_code_BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET: btrfs_err_code = 4;
pub const btrfs_err_code_BTRFS_ERROR_DEV_TGT_REPLACE: btrfs_err_code = 5;
pub const btrfs_err_code_BTRFS_ERROR_DEV_MISSING_NOT_FOUND: btrfs_err_code = 6;
pub const btrfs_err_code_BTRFS_ERROR_DEV_ONLY_WRITABLE: btrfs_err_code = 7;
pub const btrfs_err_code_BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS: btrfs_err_code = 8;
pub const btrfs_err_code_BTRFS_ERROR_DEV_RAID1C3_MIN_NOT_MET: btrfs_err_code = 9;
pub const btrfs_err_code_BTRFS_ERROR_DEV_RAID1C4_MIN_NOT_MET: btrfs_err_code = 10;
pub type btrfs_err_code = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __user_cap_header_struct {
    pub version: __u32,
    pub pid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___user_cap_header_struct() {
    assert_eq!(
        ::std::mem::size_of::<__user_cap_header_struct>(),
        8usize,
        concat!("Size of: ", stringify!(__user_cap_header_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__user_cap_header_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__user_cap_header_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__user_cap_header_struct>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__user_cap_header_struct),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__user_cap_header_struct>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__user_cap_header_struct),
            "::",
            stringify!(pid)
        )
    );
}
pub type cap_user_header_t = *mut __user_cap_header_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __user_cap_data_struct {
    pub effective: __u32,
    pub permitted: __u32,
    pub inheritable: __u32,
}
#[test]
fn bindgen_test_layout___user_cap_data_struct() {
    assert_eq!(
        ::std::mem::size_of::<__user_cap_data_struct>(),
        12usize,
        concat!("Size of: ", stringify!(__user_cap_data_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__user_cap_data_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__user_cap_data_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__user_cap_data_struct>())).effective as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__user_cap_data_struct),
            "::",
            stringify!(effective)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__user_cap_data_struct>())).permitted as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__user_cap_data_struct),
            "::",
            stringify!(permitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__user_cap_data_struct>())).inheritable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__user_cap_data_struct),
            "::",
            stringify!(inheritable)
        )
    );
}
pub type cap_user_data_t = *mut __user_cap_data_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_cap_data__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
#[test]
fn bindgen_test_layout_vfs_cap_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfs_cap_data__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vfs_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfs_cap_data__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(vfs_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfs_cap_data__bindgen_ty_1>())).permitted as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_cap_data__bindgen_ty_1),
            "::",
            stringify!(permitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfs_cap_data__bindgen_ty_1>())).inheritable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_cap_data__bindgen_ty_1),
            "::",
            stringify!(inheritable)
        )
    );
}
#[test]
fn bindgen_test_layout_vfs_cap_data() {
    assert_eq!(
        ::std::mem::size_of::<vfs_cap_data>(),
        20usize,
        concat!("Size of: ", stringify!(vfs_cap_data))
    );
    assert_eq!(
        ::std::mem::align_of::<vfs_cap_data>(),
        4usize,
        concat!("Alignment of ", stringify!(vfs_cap_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfs_cap_data>())).magic_etc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_cap_data),
            "::",
            stringify!(magic_etc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfs_cap_data>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_cap_data),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_ns_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_ns_cap_data__bindgen_ty_1; 2usize],
    pub rootid: __le32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_ns_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
#[test]
fn bindgen_test_layout_vfs_ns_cap_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfs_ns_cap_data__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vfs_ns_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfs_ns_cap_data__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(vfs_ns_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfs_ns_cap_data__bindgen_ty_1>())).permitted as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_ns_cap_data__bindgen_ty_1),
            "::",
            stringify!(permitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfs_ns_cap_data__bindgen_ty_1>())).inheritable as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_ns_cap_data__bindgen_ty_1),
            "::",
            stringify!(inheritable)
        )
    );
}
#[test]
fn bindgen_test_layout_vfs_ns_cap_data() {
    assert_eq!(
        ::std::mem::size_of::<vfs_ns_cap_data>(),
        24usize,
        concat!("Size of: ", stringify!(vfs_ns_cap_data))
    );
    assert_eq!(
        ::std::mem::align_of::<vfs_ns_cap_data>(),
        4usize,
        concat!("Alignment of ", stringify!(vfs_ns_cap_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfs_ns_cap_data>())).magic_etc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_ns_cap_data),
            "::",
            stringify!(magic_etc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfs_ns_cap_data>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_ns_cap_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfs_ns_cap_data>())).rootid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_ns_cap_data),
            "::",
            stringify!(rootid)
        )
    );
}
pub const _BTRFS_IOC_SNAP_CREATE: __u64 = 1342215169;
pub const _BTRFS_IOC_DEFRAG: __u64 = 1342215170;
pub const _BTRFS_IOC_RESIZE: __u64 = 1342215171;
pub const _BTRFS_IOC_SCAN_DEV: __u64 = 1342215172;
pub const _BTRFS_IOC_TRANS_START: __u64 = 37894;
pub const _BTRFS_IOC_TRANS_END: __u64 = 37895;
pub const _BTRFS_IOC_SYNC: __u64 = 37896;
pub const _BTRFS_IOC_CLONE: __u64 = 1074041865;
pub const _BTRFS_IOC_ADD_DEV: __u64 = 1342215178;
pub const _BTRFS_IOC_RM_DEV: __u64 = 1342215179;
pub const _BTRFS_IOC_BALANCE: __u64 = 1342215180;
pub const _BTRFS_IOC_CLONE_RANGE: __u64 = 1075876877;
pub const _BTRFS_IOC_SUBVOL_CREATE: __u64 = 1342215182;
pub const _BTRFS_IOC_SNAP_DESTROY: __u64 = 1342215183;
pub const _BTRFS_IOC_DEFRAG_RANGE: __u64 = 1076925456;
pub const _BTRFS_IOC_TREE_SEARCH: __u64 = 3489698833;
pub const _BTRFS_IOC_TREE_SEARCH_V2: __u64 = 3228603409;
pub const _BTRFS_IOC_INO_LOOKUP: __u64 = 3489698834;
pub const _BTRFS_IOC_DEFAULT_SUBVOL: __u64 = 1074304019;
pub const _BTRFS_IOC_SPACE_INFO: __u64 = 3222311956;
pub const _BTRFS_IOC_START_SYNC: __u64 = 2148045848;
pub const _BTRFS_IOC_WAIT_SYNC: __u64 = 1074304022;
pub const _BTRFS_IOC_SNAP_CREATE_V2: __u64 = 1342215191;
pub const _BTRFS_IOC_SUBVOL_CREATE_V2: __u64 = 1342215192;
pub const _BTRFS_IOC_SUBVOL_GETFLAGS: __u64 = 2148045849;
pub const _BTRFS_IOC_SUBVOL_SETFLAGS: __u64 = 1074304026;
pub const _BTRFS_IOC_SCRUB: __u64 = 3288372251;
pub const _BTRFS_IOC_SCRUB_CANCEL: __u64 = 37916;
pub const _BTRFS_IOC_SCRUB_PROGRESS: __u64 = 3288372253;
pub const _BTRFS_IOC_DEV_INFO: __u64 = 3489698846;
pub const _BTRFS_IOC_FS_INFO: __u64 = 2214630431;
pub const _BTRFS_IOC_BALANCE_V2: __u64 = 3288372256;
pub const _BTRFS_IOC_BALANCE_CTL: __u64 = 1074041889;
pub const _BTRFS_IOC_BALANCE_PROGRESS: __u64 = 2214630434;
pub const _BTRFS_IOC_INO_PATHS: __u64 = 3224933411;
pub const _BTRFS_IOC_LOGICAL_INO: __u64 = 3224933412;
pub const _BTRFS_IOC_SET_RECEIVED_SUBVOL: __u64 = 3234370597;
pub const _BTRFS_IOC_SEND: __u64 = 1078498342;
pub const _BTRFS_IOC_DEVICES_READY: __u64 = 2415957031;
pub const _BTRFS_IOC_QUOTA_CTL: __u64 = 3222311976;
pub const _BTRFS_IOC_QGROUP_ASSIGN: __u64 = 1075352617;
pub const _BTRFS_IOC_QGROUP_CREATE: __u64 = 1074828330;
pub const _BTRFS_IOC_QGROUP_LIMIT: __u64 = 2150667307;
pub const _BTRFS_IOC_QUOTA_RESCAN: __u64 = 1077974060;
pub const _BTRFS_IOC_QUOTA_RESCAN_STATUS: __u64 = 2151715885;
pub const _BTRFS_IOC_QUOTA_RESCAN_WAIT: __u64 = 37934;
pub const _BTRFS_IOC_GET_FSLABEL: __u64 = 2164298801;
pub const _BTRFS_IOC_SET_FSLABEL: __u64 = 1090556978;
pub const _BTRFS_IOC_GET_DEV_STATS: __u64 = 3288896564;
pub const _BTRFS_IOC_DEV_REPLACE: __u64 = 3391657013;
pub const _BTRFS_IOC_FILE_EXTENT_SAME: __u64 = 3222836278;
pub const _BTRFS_IOC_GET_FEATURES: __u64 = 2149094457;
pub const _BTRFS_IOC_SET_FEATURES: __u64 = 1076925497;
pub const _BTRFS_IOC_GET_SUPPORTED_FEATURES: __u64 = 2152240185;
pub const _BTRFS_IOC_RM_DEV_V2: __u64 = 1342215226;
pub const _BTRFS_IOC_LOGICAL_INO_V2: __u64 = 3224933435;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub _address: u8,
}
